// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SCHWABEXPIRATIONCHAIN_SCHWABMARKETDATA_H_
#define FLATBUFFERS_GENERATED_SCHWABEXPIRATIONCHAIN_SCHWABMARKETDATA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

#include "schwab_optionsenums_generated.h"

namespace schwabMarketData {

struct Expiration;
struct ExpirationBuilder;
struct ExpirationT;

struct ExpirationChain;
struct ExpirationChainBuilder;
struct ExpirationChainT;

bool operator==(const ExpirationT &lhs, const ExpirationT &rhs);
bool operator!=(const ExpirationT &lhs, const ExpirationT &rhs);
bool operator==(const ExpirationChainT &lhs, const ExpirationChainT &rhs);
bool operator!=(const ExpirationChainT &lhs, const ExpirationChainT &rhs);

struct ExpirationT : public ::flatbuffers::NativeTable {
  typedef Expiration TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "schwabMarketData.ExpirationT";
  }
  int32_t daysToExpiration = 0;
  std::string expiration{};
  schwabMarketData::ExpirationType expirationType = schwabMarketData::ExpirationType::M;
  bool standard = false;
  schwabMarketData::SettlementType settlmentType = schwabMarketData::SettlementType::A;
  std::string optionRoots{};
};

struct Expiration FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ExpirationT NativeTableType;
  typedef ExpirationBuilder Builder;
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "schwabMarketData.Expiration";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DAYSTOEXPIRATION = 4,
    VT_EXPIRATION = 6,
    VT_EXPIRATIONTYPE = 8,
    VT_STANDARD = 10,
    VT_SETTLMENTTYPE = 12,
    VT_OPTIONROOTS = 14
  };
  int32_t daysToExpiration() const {
    return GetField<int32_t>(VT_DAYSTOEXPIRATION, 0);
  }
  bool mutate_daysToExpiration(int32_t _daysToExpiration = 0) {
    return SetField<int32_t>(VT_DAYSTOEXPIRATION, _daysToExpiration, 0);
  }
  const ::flatbuffers::String *expiration() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EXPIRATION);
  }
  ::flatbuffers::String *mutable_expiration() {
    return GetPointer<::flatbuffers::String *>(VT_EXPIRATION);
  }
  schwabMarketData::ExpirationType expirationType() const {
    return static_cast<schwabMarketData::ExpirationType>(GetField<int8_t>(VT_EXPIRATIONTYPE, 0));
  }
  bool mutate_expirationType(schwabMarketData::ExpirationType _expirationType = static_cast<schwabMarketData::ExpirationType>(0)) {
    return SetField<int8_t>(VT_EXPIRATIONTYPE, static_cast<int8_t>(_expirationType), 0);
  }
  bool standard() const {
    return GetField<uint8_t>(VT_STANDARD, 0) != 0;
  }
  bool mutate_standard(bool _standard = 0) {
    return SetField<uint8_t>(VT_STANDARD, static_cast<uint8_t>(_standard), 0);
  }
  schwabMarketData::SettlementType settlmentType() const {
    return static_cast<schwabMarketData::SettlementType>(GetField<int8_t>(VT_SETTLMENTTYPE, 0));
  }
  bool mutate_settlmentType(schwabMarketData::SettlementType _settlmentType = static_cast<schwabMarketData::SettlementType>(0)) {
    return SetField<int8_t>(VT_SETTLMENTTYPE, static_cast<int8_t>(_settlmentType), 0);
  }
  const ::flatbuffers::String *optionRoots() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OPTIONROOTS);
  }
  ::flatbuffers::String *mutable_optionRoots() {
    return GetPointer<::flatbuffers::String *>(VT_OPTIONROOTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_DAYSTOEXPIRATION, 4) &&
           VerifyOffset(verifier, VT_EXPIRATION) &&
           verifier.VerifyString(expiration()) &&
           VerifyField<int8_t>(verifier, VT_EXPIRATIONTYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_STANDARD, 1) &&
           VerifyField<int8_t>(verifier, VT_SETTLMENTTYPE, 1) &&
           VerifyOffset(verifier, VT_OPTIONROOTS) &&
           verifier.VerifyString(optionRoots()) &&
           verifier.EndTable();
  }
  ExpirationT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ExpirationT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Expiration> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ExpirationT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ExpirationBuilder {
  typedef Expiration Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_daysToExpiration(int32_t daysToExpiration) {
    fbb_.AddElement<int32_t>(Expiration::VT_DAYSTOEXPIRATION, daysToExpiration, 0);
  }
  void add_expiration(::flatbuffers::Offset<::flatbuffers::String> expiration) {
    fbb_.AddOffset(Expiration::VT_EXPIRATION, expiration);
  }
  void add_expirationType(schwabMarketData::ExpirationType expirationType) {
    fbb_.AddElement<int8_t>(Expiration::VT_EXPIRATIONTYPE, static_cast<int8_t>(expirationType), 0);
  }
  void add_standard(bool standard) {
    fbb_.AddElement<uint8_t>(Expiration::VT_STANDARD, static_cast<uint8_t>(standard), 0);
  }
  void add_settlmentType(schwabMarketData::SettlementType settlmentType) {
    fbb_.AddElement<int8_t>(Expiration::VT_SETTLMENTTYPE, static_cast<int8_t>(settlmentType), 0);
  }
  void add_optionRoots(::flatbuffers::Offset<::flatbuffers::String> optionRoots) {
    fbb_.AddOffset(Expiration::VT_OPTIONROOTS, optionRoots);
  }
  explicit ExpirationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Expiration> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Expiration>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Expiration> CreateExpiration(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t daysToExpiration = 0,
    ::flatbuffers::Offset<::flatbuffers::String> expiration = 0,
    schwabMarketData::ExpirationType expirationType = schwabMarketData::ExpirationType::M,
    bool standard = false,
    schwabMarketData::SettlementType settlmentType = schwabMarketData::SettlementType::A,
    ::flatbuffers::Offset<::flatbuffers::String> optionRoots = 0) {
  ExpirationBuilder builder_(_fbb);
  builder_.add_optionRoots(optionRoots);
  builder_.add_expiration(expiration);
  builder_.add_daysToExpiration(daysToExpiration);
  builder_.add_settlmentType(settlmentType);
  builder_.add_standard(standard);
  builder_.add_expirationType(expirationType);
  return builder_.Finish();
}

struct Expiration::Traits {
  using type = Expiration;
  static auto constexpr Create = CreateExpiration;
};

inline ::flatbuffers::Offset<Expiration> CreateExpirationDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t daysToExpiration = 0,
    const char *expiration = nullptr,
    schwabMarketData::ExpirationType expirationType = schwabMarketData::ExpirationType::M,
    bool standard = false,
    schwabMarketData::SettlementType settlmentType = schwabMarketData::SettlementType::A,
    const char *optionRoots = nullptr) {
  auto expiration__ = expiration ? _fbb.CreateString(expiration) : 0;
  auto optionRoots__ = optionRoots ? _fbb.CreateString(optionRoots) : 0;
  return schwabMarketData::CreateExpiration(
      _fbb,
      daysToExpiration,
      expiration__,
      expirationType,
      standard,
      settlmentType,
      optionRoots__);
}

::flatbuffers::Offset<Expiration> CreateExpiration(::flatbuffers::FlatBufferBuilder &_fbb, const ExpirationT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ExpirationChainT : public ::flatbuffers::NativeTable {
  typedef ExpirationChain TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "schwabMarketData.ExpirationChainT";
  }
  std::string status{};
  std::vector<std::unique_ptr<schwabMarketData::ExpirationT>> expirationList{};
  ExpirationChainT() = default;
  ExpirationChainT(const ExpirationChainT &o);
  ExpirationChainT(ExpirationChainT&&) FLATBUFFERS_NOEXCEPT = default;
  ExpirationChainT &operator=(ExpirationChainT o) FLATBUFFERS_NOEXCEPT;
};

struct ExpirationChain FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ExpirationChainT NativeTableType;
  typedef ExpirationChainBuilder Builder;
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "schwabMarketData.ExpirationChain";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATUS = 4,
    VT_EXPIRATIONLIST = 6
  };
  const ::flatbuffers::String *status() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STATUS);
  }
  ::flatbuffers::String *mutable_status() {
    return GetPointer<::flatbuffers::String *>(VT_STATUS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<schwabMarketData::Expiration>> *expirationList() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<schwabMarketData::Expiration>> *>(VT_EXPIRATIONLIST);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<schwabMarketData::Expiration>> *mutable_expirationList() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<schwabMarketData::Expiration>> *>(VT_EXPIRATIONLIST);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STATUS) &&
           verifier.VerifyString(status()) &&
           VerifyOffset(verifier, VT_EXPIRATIONLIST) &&
           verifier.VerifyVector(expirationList()) &&
           verifier.VerifyVectorOfTables(expirationList()) &&
           verifier.EndTable();
  }
  ExpirationChainT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ExpirationChainT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ExpirationChain> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ExpirationChainT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ExpirationChainBuilder {
  typedef ExpirationChain Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_status(::flatbuffers::Offset<::flatbuffers::String> status) {
    fbb_.AddOffset(ExpirationChain::VT_STATUS, status);
  }
  void add_expirationList(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<schwabMarketData::Expiration>>> expirationList) {
    fbb_.AddOffset(ExpirationChain::VT_EXPIRATIONLIST, expirationList);
  }
  explicit ExpirationChainBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ExpirationChain> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ExpirationChain>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ExpirationChain> CreateExpirationChain(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> status = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<schwabMarketData::Expiration>>> expirationList = 0) {
  ExpirationChainBuilder builder_(_fbb);
  builder_.add_expirationList(expirationList);
  builder_.add_status(status);
  return builder_.Finish();
}

struct ExpirationChain::Traits {
  using type = ExpirationChain;
  static auto constexpr Create = CreateExpirationChain;
};

inline ::flatbuffers::Offset<ExpirationChain> CreateExpirationChainDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *status = nullptr,
    const std::vector<::flatbuffers::Offset<schwabMarketData::Expiration>> *expirationList = nullptr) {
  auto status__ = status ? _fbb.CreateString(status) : 0;
  auto expirationList__ = expirationList ? _fbb.CreateVector<::flatbuffers::Offset<schwabMarketData::Expiration>>(*expirationList) : 0;
  return schwabMarketData::CreateExpirationChain(
      _fbb,
      status__,
      expirationList__);
}

::flatbuffers::Offset<ExpirationChain> CreateExpirationChain(::flatbuffers::FlatBufferBuilder &_fbb, const ExpirationChainT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);


inline bool operator==(const ExpirationT &lhs, const ExpirationT &rhs) {
  return
      (lhs.daysToExpiration == rhs.daysToExpiration) &&
      (lhs.expiration == rhs.expiration) &&
      (lhs.expirationType == rhs.expirationType) &&
      (lhs.standard == rhs.standard) &&
      (lhs.settlmentType == rhs.settlmentType) &&
      (lhs.optionRoots == rhs.optionRoots);
}

inline bool operator!=(const ExpirationT &lhs, const ExpirationT &rhs) {
    return !(lhs == rhs);
}


inline ExpirationT *Expiration::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<ExpirationT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Expiration::UnPackTo(ExpirationT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = daysToExpiration(); _o->daysToExpiration = _e; }
  { auto _e = expiration(); if (_e) _o->expiration = _e->str(); }
  { auto _e = expirationType(); _o->expirationType = _e; }
  { auto _e = standard(); _o->standard = _e; }
  { auto _e = settlmentType(); _o->settlmentType = _e; }
  { auto _e = optionRoots(); if (_e) _o->optionRoots = _e->str(); }
}

inline ::flatbuffers::Offset<Expiration> Expiration::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ExpirationT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateExpiration(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Expiration> CreateExpiration(::flatbuffers::FlatBufferBuilder &_fbb, const ExpirationT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ExpirationT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _daysToExpiration = _o->daysToExpiration;
  auto _expiration = _o->expiration.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->expiration);
  auto _expirationType = _o->expirationType;
  auto _standard = _o->standard;
  auto _settlmentType = _o->settlmentType;
  auto _optionRoots = _o->optionRoots.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->optionRoots);
  return schwabMarketData::CreateExpiration(
      _fbb,
      _daysToExpiration,
      _expiration,
      _expirationType,
      _standard,
      _settlmentType,
      _optionRoots);
}


inline bool operator==(const ExpirationChainT &lhs, const ExpirationChainT &rhs) {
  return
      (lhs.status == rhs.status) &&
      (lhs.expirationList.size() == rhs.expirationList.size() && std::equal(lhs.expirationList.cbegin(), lhs.expirationList.cend(), rhs.expirationList.cbegin(), [](std::unique_ptr<schwabMarketData::ExpirationT> const &a, std::unique_ptr<schwabMarketData::ExpirationT> const &b) { return (a == b) || (a && b && *a == *b); }));
}

inline bool operator!=(const ExpirationChainT &lhs, const ExpirationChainT &rhs) {
    return !(lhs == rhs);
}


inline ExpirationChainT::ExpirationChainT(const ExpirationChainT &o)
      : status(o.status) {
  expirationList.reserve(o.expirationList.size());
  for (const auto &expirationList_ : o.expirationList) { expirationList.emplace_back((expirationList_) ? new schwabMarketData::ExpirationT(*expirationList_) : nullptr); }
}

inline ExpirationChainT &ExpirationChainT::operator=(ExpirationChainT o) FLATBUFFERS_NOEXCEPT {
  std::swap(status, o.status);
  std::swap(expirationList, o.expirationList);
  return *this;
}

inline ExpirationChainT *ExpirationChain::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<ExpirationChainT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ExpirationChain::UnPackTo(ExpirationChainT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = status(); if (_e) _o->status = _e->str(); }
  { auto _e = expirationList(); if (_e) { _o->expirationList.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->expirationList[_i]) { _e->Get(_i)->UnPackTo(_o->expirationList[_i].get(), _resolver); } else { _o->expirationList[_i] = std::unique_ptr<schwabMarketData::ExpirationT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->expirationList.resize(0); } }
}

inline ::flatbuffers::Offset<ExpirationChain> ExpirationChain::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ExpirationChainT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateExpirationChain(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ExpirationChain> CreateExpirationChain(::flatbuffers::FlatBufferBuilder &_fbb, const ExpirationChainT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ExpirationChainT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _status = _o->status.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->status);
  auto _expirationList = _fbb.CreateVector<::flatbuffers::Offset<schwabMarketData::Expiration>> (_o->expirationList.size(), [](size_t i, _VectorArgs *__va) { return CreateExpiration(*__va->__fbb, __va->__o->expirationList[i].get(), __va->__rehasher); }, &_va );
  return schwabMarketData::CreateExpirationChain(
      _fbb,
      _status,
      _expirationList);
}

inline const schwabMarketData::ExpirationChain *GetExpirationChain(const void *buf) {
  return ::flatbuffers::GetRoot<schwabMarketData::ExpirationChain>(buf);
}

inline const schwabMarketData::ExpirationChain *GetSizePrefixedExpirationChain(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<schwabMarketData::ExpirationChain>(buf);
}

inline ExpirationChain *GetMutableExpirationChain(void *buf) {
  return ::flatbuffers::GetMutableRoot<ExpirationChain>(buf);
}

inline schwabMarketData::ExpirationChain *GetMutableSizePrefixedExpirationChain(void *buf) {
  return ::flatbuffers::GetMutableSizePrefixedRoot<schwabMarketData::ExpirationChain>(buf);
}

inline bool VerifyExpirationChainBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<schwabMarketData::ExpirationChain>(nullptr);
}

inline bool VerifySizePrefixedExpirationChainBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<schwabMarketData::ExpirationChain>(nullptr);
}

inline void FinishExpirationChainBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<schwabMarketData::ExpirationChain> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedExpirationChainBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<schwabMarketData::ExpirationChain> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<schwabMarketData::ExpirationChainT> UnPackExpirationChain(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<schwabMarketData::ExpirationChainT>(GetExpirationChain(buf)->UnPack(res));
}

inline std::unique_ptr<schwabMarketData::ExpirationChainT> UnPackSizePrefixedExpirationChain(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<schwabMarketData::ExpirationChainT>(GetSizePrefixedExpirationChain(buf)->UnPack(res));
}

}  // namespace schwabMarketData

#endif  // FLATBUFFERS_GENERATED_SCHWABEXPIRATIONCHAIN_SCHWABMARKETDATA_H_
