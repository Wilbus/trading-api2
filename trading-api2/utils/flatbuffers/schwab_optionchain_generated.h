// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SCHWABOPTIONCHAIN_SCHWABMARKETDATA_H_
#define FLATBUFFERS_GENERATED_SCHWABOPTIONCHAIN_SCHWABMARKETDATA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

#include "schwab_optionsenums_generated.h"

namespace schwabMarketData {

struct Underlying;
struct UnderlyingBuilder;
struct UnderlyingT;

struct OptionDeliverables;
struct OptionDeliverablesBuilder;
struct OptionDeliverablesT;

struct OptionContract;
struct OptionContractBuilder;
struct OptionContractT;

struct OptionContractMap;
struct OptionContractMapBuilder;
struct OptionContractMapT;

struct OptionChain;
struct OptionChainBuilder;
struct OptionChainT;

bool operator==(const UnderlyingT &lhs, const UnderlyingT &rhs);
bool operator!=(const UnderlyingT &lhs, const UnderlyingT &rhs);
bool operator==(const OptionDeliverablesT &lhs, const OptionDeliverablesT &rhs);
bool operator!=(const OptionDeliverablesT &lhs, const OptionDeliverablesT &rhs);
bool operator==(const OptionContractT &lhs, const OptionContractT &rhs);
bool operator!=(const OptionContractT &lhs, const OptionContractT &rhs);
bool operator==(const OptionContractMapT &lhs, const OptionContractMapT &rhs);
bool operator!=(const OptionContractMapT &lhs, const OptionContractMapT &rhs);
bool operator==(const OptionChainT &lhs, const OptionChainT &rhs);
bool operator!=(const OptionChainT &lhs, const OptionChainT &rhs);

struct UnderlyingT : public ::flatbuffers::NativeTable {
  typedef Underlying TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "schwabMarketData.UnderlyingT";
  }
  double ask = 0.0;
  int32_t askSize = 0;
  double bid = 0.0;
  int32_t bidSize = 0;
  double change = 0.0;
  double close = 0.0;
  bool delayed = false;
  std::string description{};
  schwabMarketData::ExchangeName exchangeName = schwabMarketData::ExchangeName::IND;
  double fiftyTwoWeekHigh = 0.0;
  double fiftyTwoWeekLow = 0.0;
  double highPrice = 0.0;
  double last = 0.0;
  double lowPrice = 0.0;
  double mark = 0.0;
  double markChange = 0.0;
  double markPercentChange = 0.0;
  double openPrice = 0.0;
  double percentChange = 0.0;
  int64_t quoteTime = 0;
  std::string symbol{};
  int64_t totalVolume = 0;
  int64_t tradeTime = 0;
};

struct Underlying FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UnderlyingT NativeTableType;
  typedef UnderlyingBuilder Builder;
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "schwabMarketData.Underlying";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ASK = 4,
    VT_ASKSIZE = 6,
    VT_BID = 8,
    VT_BIDSIZE = 10,
    VT_CHANGE = 12,
    VT_CLOSE = 14,
    VT_DELAYED = 16,
    VT_DESCRIPTION = 18,
    VT_EXCHANGENAME = 20,
    VT_FIFTYTWOWEEKHIGH = 22,
    VT_FIFTYTWOWEEKLOW = 24,
    VT_HIGHPRICE = 26,
    VT_LAST = 28,
    VT_LOWPRICE = 30,
    VT_MARK = 32,
    VT_MARKCHANGE = 34,
    VT_MARKPERCENTCHANGE = 36,
    VT_OPENPRICE = 38,
    VT_PERCENTCHANGE = 40,
    VT_QUOTETIME = 42,
    VT_SYMBOL = 44,
    VT_TOTALVOLUME = 46,
    VT_TRADETIME = 48
  };
  double ask() const {
    return GetField<double>(VT_ASK, 0.0);
  }
  bool mutate_ask(double _ask = 0.0) {
    return SetField<double>(VT_ASK, _ask, 0.0);
  }
  int32_t askSize() const {
    return GetField<int32_t>(VT_ASKSIZE, 0);
  }
  bool mutate_askSize(int32_t _askSize = 0) {
    return SetField<int32_t>(VT_ASKSIZE, _askSize, 0);
  }
  double bid() const {
    return GetField<double>(VT_BID, 0.0);
  }
  bool mutate_bid(double _bid = 0.0) {
    return SetField<double>(VT_BID, _bid, 0.0);
  }
  int32_t bidSize() const {
    return GetField<int32_t>(VT_BIDSIZE, 0);
  }
  bool mutate_bidSize(int32_t _bidSize = 0) {
    return SetField<int32_t>(VT_BIDSIZE, _bidSize, 0);
  }
  double change() const {
    return GetField<double>(VT_CHANGE, 0.0);
  }
  bool mutate_change(double _change = 0.0) {
    return SetField<double>(VT_CHANGE, _change, 0.0);
  }
  double close() const {
    return GetField<double>(VT_CLOSE, 0.0);
  }
  bool mutate_close(double _close = 0.0) {
    return SetField<double>(VT_CLOSE, _close, 0.0);
  }
  bool delayed() const {
    return GetField<uint8_t>(VT_DELAYED, 0) != 0;
  }
  bool mutate_delayed(bool _delayed = 0) {
    return SetField<uint8_t>(VT_DELAYED, static_cast<uint8_t>(_delayed), 0);
  }
  const ::flatbuffers::String *description() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  ::flatbuffers::String *mutable_description() {
    return GetPointer<::flatbuffers::String *>(VT_DESCRIPTION);
  }
  schwabMarketData::ExchangeName exchangeName() const {
    return static_cast<schwabMarketData::ExchangeName>(GetField<int8_t>(VT_EXCHANGENAME, 0));
  }
  bool mutate_exchangeName(schwabMarketData::ExchangeName _exchangeName = static_cast<schwabMarketData::ExchangeName>(0)) {
    return SetField<int8_t>(VT_EXCHANGENAME, static_cast<int8_t>(_exchangeName), 0);
  }
  double fiftyTwoWeekHigh() const {
    return GetField<double>(VT_FIFTYTWOWEEKHIGH, 0.0);
  }
  bool mutate_fiftyTwoWeekHigh(double _fiftyTwoWeekHigh = 0.0) {
    return SetField<double>(VT_FIFTYTWOWEEKHIGH, _fiftyTwoWeekHigh, 0.0);
  }
  double fiftyTwoWeekLow() const {
    return GetField<double>(VT_FIFTYTWOWEEKLOW, 0.0);
  }
  bool mutate_fiftyTwoWeekLow(double _fiftyTwoWeekLow = 0.0) {
    return SetField<double>(VT_FIFTYTWOWEEKLOW, _fiftyTwoWeekLow, 0.0);
  }
  double highPrice() const {
    return GetField<double>(VT_HIGHPRICE, 0.0);
  }
  bool mutate_highPrice(double _highPrice = 0.0) {
    return SetField<double>(VT_HIGHPRICE, _highPrice, 0.0);
  }
  double last() const {
    return GetField<double>(VT_LAST, 0.0);
  }
  bool mutate_last(double _last = 0.0) {
    return SetField<double>(VT_LAST, _last, 0.0);
  }
  double lowPrice() const {
    return GetField<double>(VT_LOWPRICE, 0.0);
  }
  bool mutate_lowPrice(double _lowPrice = 0.0) {
    return SetField<double>(VT_LOWPRICE, _lowPrice, 0.0);
  }
  double mark() const {
    return GetField<double>(VT_MARK, 0.0);
  }
  bool mutate_mark(double _mark = 0.0) {
    return SetField<double>(VT_MARK, _mark, 0.0);
  }
  double markChange() const {
    return GetField<double>(VT_MARKCHANGE, 0.0);
  }
  bool mutate_markChange(double _markChange = 0.0) {
    return SetField<double>(VT_MARKCHANGE, _markChange, 0.0);
  }
  double markPercentChange() const {
    return GetField<double>(VT_MARKPERCENTCHANGE, 0.0);
  }
  bool mutate_markPercentChange(double _markPercentChange = 0.0) {
    return SetField<double>(VT_MARKPERCENTCHANGE, _markPercentChange, 0.0);
  }
  double openPrice() const {
    return GetField<double>(VT_OPENPRICE, 0.0);
  }
  bool mutate_openPrice(double _openPrice = 0.0) {
    return SetField<double>(VT_OPENPRICE, _openPrice, 0.0);
  }
  double percentChange() const {
    return GetField<double>(VT_PERCENTCHANGE, 0.0);
  }
  bool mutate_percentChange(double _percentChange = 0.0) {
    return SetField<double>(VT_PERCENTCHANGE, _percentChange, 0.0);
  }
  int64_t quoteTime() const {
    return GetField<int64_t>(VT_QUOTETIME, 0);
  }
  bool mutate_quoteTime(int64_t _quoteTime = 0) {
    return SetField<int64_t>(VT_QUOTETIME, _quoteTime, 0);
  }
  const ::flatbuffers::String *symbol() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SYMBOL);
  }
  ::flatbuffers::String *mutable_symbol() {
    return GetPointer<::flatbuffers::String *>(VT_SYMBOL);
  }
  int64_t totalVolume() const {
    return GetField<int64_t>(VT_TOTALVOLUME, 0);
  }
  bool mutate_totalVolume(int64_t _totalVolume = 0) {
    return SetField<int64_t>(VT_TOTALVOLUME, _totalVolume, 0);
  }
  int64_t tradeTime() const {
    return GetField<int64_t>(VT_TRADETIME, 0);
  }
  bool mutate_tradeTime(int64_t _tradeTime = 0) {
    return SetField<int64_t>(VT_TRADETIME, _tradeTime, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_ASK, 8) &&
           VerifyField<int32_t>(verifier, VT_ASKSIZE, 4) &&
           VerifyField<double>(verifier, VT_BID, 8) &&
           VerifyField<int32_t>(verifier, VT_BIDSIZE, 4) &&
           VerifyField<double>(verifier, VT_CHANGE, 8) &&
           VerifyField<double>(verifier, VT_CLOSE, 8) &&
           VerifyField<uint8_t>(verifier, VT_DELAYED, 1) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           VerifyField<int8_t>(verifier, VT_EXCHANGENAME, 1) &&
           VerifyField<double>(verifier, VT_FIFTYTWOWEEKHIGH, 8) &&
           VerifyField<double>(verifier, VT_FIFTYTWOWEEKLOW, 8) &&
           VerifyField<double>(verifier, VT_HIGHPRICE, 8) &&
           VerifyField<double>(verifier, VT_LAST, 8) &&
           VerifyField<double>(verifier, VT_LOWPRICE, 8) &&
           VerifyField<double>(verifier, VT_MARK, 8) &&
           VerifyField<double>(verifier, VT_MARKCHANGE, 8) &&
           VerifyField<double>(verifier, VT_MARKPERCENTCHANGE, 8) &&
           VerifyField<double>(verifier, VT_OPENPRICE, 8) &&
           VerifyField<double>(verifier, VT_PERCENTCHANGE, 8) &&
           VerifyField<int64_t>(verifier, VT_QUOTETIME, 8) &&
           VerifyOffset(verifier, VT_SYMBOL) &&
           verifier.VerifyString(symbol()) &&
           VerifyField<int64_t>(verifier, VT_TOTALVOLUME, 8) &&
           VerifyField<int64_t>(verifier, VT_TRADETIME, 8) &&
           verifier.EndTable();
  }
  UnderlyingT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnderlyingT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Underlying> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UnderlyingT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnderlyingBuilder {
  typedef Underlying Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ask(double ask) {
    fbb_.AddElement<double>(Underlying::VT_ASK, ask, 0.0);
  }
  void add_askSize(int32_t askSize) {
    fbb_.AddElement<int32_t>(Underlying::VT_ASKSIZE, askSize, 0);
  }
  void add_bid(double bid) {
    fbb_.AddElement<double>(Underlying::VT_BID, bid, 0.0);
  }
  void add_bidSize(int32_t bidSize) {
    fbb_.AddElement<int32_t>(Underlying::VT_BIDSIZE, bidSize, 0);
  }
  void add_change(double change) {
    fbb_.AddElement<double>(Underlying::VT_CHANGE, change, 0.0);
  }
  void add_close(double close) {
    fbb_.AddElement<double>(Underlying::VT_CLOSE, close, 0.0);
  }
  void add_delayed(bool delayed) {
    fbb_.AddElement<uint8_t>(Underlying::VT_DELAYED, static_cast<uint8_t>(delayed), 0);
  }
  void add_description(::flatbuffers::Offset<::flatbuffers::String> description) {
    fbb_.AddOffset(Underlying::VT_DESCRIPTION, description);
  }
  void add_exchangeName(schwabMarketData::ExchangeName exchangeName) {
    fbb_.AddElement<int8_t>(Underlying::VT_EXCHANGENAME, static_cast<int8_t>(exchangeName), 0);
  }
  void add_fiftyTwoWeekHigh(double fiftyTwoWeekHigh) {
    fbb_.AddElement<double>(Underlying::VT_FIFTYTWOWEEKHIGH, fiftyTwoWeekHigh, 0.0);
  }
  void add_fiftyTwoWeekLow(double fiftyTwoWeekLow) {
    fbb_.AddElement<double>(Underlying::VT_FIFTYTWOWEEKLOW, fiftyTwoWeekLow, 0.0);
  }
  void add_highPrice(double highPrice) {
    fbb_.AddElement<double>(Underlying::VT_HIGHPRICE, highPrice, 0.0);
  }
  void add_last(double last) {
    fbb_.AddElement<double>(Underlying::VT_LAST, last, 0.0);
  }
  void add_lowPrice(double lowPrice) {
    fbb_.AddElement<double>(Underlying::VT_LOWPRICE, lowPrice, 0.0);
  }
  void add_mark(double mark) {
    fbb_.AddElement<double>(Underlying::VT_MARK, mark, 0.0);
  }
  void add_markChange(double markChange) {
    fbb_.AddElement<double>(Underlying::VT_MARKCHANGE, markChange, 0.0);
  }
  void add_markPercentChange(double markPercentChange) {
    fbb_.AddElement<double>(Underlying::VT_MARKPERCENTCHANGE, markPercentChange, 0.0);
  }
  void add_openPrice(double openPrice) {
    fbb_.AddElement<double>(Underlying::VT_OPENPRICE, openPrice, 0.0);
  }
  void add_percentChange(double percentChange) {
    fbb_.AddElement<double>(Underlying::VT_PERCENTCHANGE, percentChange, 0.0);
  }
  void add_quoteTime(int64_t quoteTime) {
    fbb_.AddElement<int64_t>(Underlying::VT_QUOTETIME, quoteTime, 0);
  }
  void add_symbol(::flatbuffers::Offset<::flatbuffers::String> symbol) {
    fbb_.AddOffset(Underlying::VT_SYMBOL, symbol);
  }
  void add_totalVolume(int64_t totalVolume) {
    fbb_.AddElement<int64_t>(Underlying::VT_TOTALVOLUME, totalVolume, 0);
  }
  void add_tradeTime(int64_t tradeTime) {
    fbb_.AddElement<int64_t>(Underlying::VT_TRADETIME, tradeTime, 0);
  }
  explicit UnderlyingBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Underlying> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Underlying>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Underlying> CreateUnderlying(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double ask = 0.0,
    int32_t askSize = 0,
    double bid = 0.0,
    int32_t bidSize = 0,
    double change = 0.0,
    double close = 0.0,
    bool delayed = false,
    ::flatbuffers::Offset<::flatbuffers::String> description = 0,
    schwabMarketData::ExchangeName exchangeName = schwabMarketData::ExchangeName::IND,
    double fiftyTwoWeekHigh = 0.0,
    double fiftyTwoWeekLow = 0.0,
    double highPrice = 0.0,
    double last = 0.0,
    double lowPrice = 0.0,
    double mark = 0.0,
    double markChange = 0.0,
    double markPercentChange = 0.0,
    double openPrice = 0.0,
    double percentChange = 0.0,
    int64_t quoteTime = 0,
    ::flatbuffers::Offset<::flatbuffers::String> symbol = 0,
    int64_t totalVolume = 0,
    int64_t tradeTime = 0) {
  UnderlyingBuilder builder_(_fbb);
  builder_.add_tradeTime(tradeTime);
  builder_.add_totalVolume(totalVolume);
  builder_.add_quoteTime(quoteTime);
  builder_.add_percentChange(percentChange);
  builder_.add_openPrice(openPrice);
  builder_.add_markPercentChange(markPercentChange);
  builder_.add_markChange(markChange);
  builder_.add_mark(mark);
  builder_.add_lowPrice(lowPrice);
  builder_.add_last(last);
  builder_.add_highPrice(highPrice);
  builder_.add_fiftyTwoWeekLow(fiftyTwoWeekLow);
  builder_.add_fiftyTwoWeekHigh(fiftyTwoWeekHigh);
  builder_.add_close(close);
  builder_.add_change(change);
  builder_.add_bid(bid);
  builder_.add_ask(ask);
  builder_.add_symbol(symbol);
  builder_.add_description(description);
  builder_.add_bidSize(bidSize);
  builder_.add_askSize(askSize);
  builder_.add_exchangeName(exchangeName);
  builder_.add_delayed(delayed);
  return builder_.Finish();
}

struct Underlying::Traits {
  using type = Underlying;
  static auto constexpr Create = CreateUnderlying;
};

inline ::flatbuffers::Offset<Underlying> CreateUnderlyingDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double ask = 0.0,
    int32_t askSize = 0,
    double bid = 0.0,
    int32_t bidSize = 0,
    double change = 0.0,
    double close = 0.0,
    bool delayed = false,
    const char *description = nullptr,
    schwabMarketData::ExchangeName exchangeName = schwabMarketData::ExchangeName::IND,
    double fiftyTwoWeekHigh = 0.0,
    double fiftyTwoWeekLow = 0.0,
    double highPrice = 0.0,
    double last = 0.0,
    double lowPrice = 0.0,
    double mark = 0.0,
    double markChange = 0.0,
    double markPercentChange = 0.0,
    double openPrice = 0.0,
    double percentChange = 0.0,
    int64_t quoteTime = 0,
    const char *symbol = nullptr,
    int64_t totalVolume = 0,
    int64_t tradeTime = 0) {
  auto description__ = description ? _fbb.CreateString(description) : 0;
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  return schwabMarketData::CreateUnderlying(
      _fbb,
      ask,
      askSize,
      bid,
      bidSize,
      change,
      close,
      delayed,
      description__,
      exchangeName,
      fiftyTwoWeekHigh,
      fiftyTwoWeekLow,
      highPrice,
      last,
      lowPrice,
      mark,
      markChange,
      markPercentChange,
      openPrice,
      percentChange,
      quoteTime,
      symbol__,
      totalVolume,
      tradeTime);
}

::flatbuffers::Offset<Underlying> CreateUnderlying(::flatbuffers::FlatBufferBuilder &_fbb, const UnderlyingT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OptionDeliverablesT : public ::flatbuffers::NativeTable {
  typedef OptionDeliverables TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "schwabMarketData.OptionDeliverablesT";
  }
  std::string symbol{};
  std::string assetType{};
  std::string deliverableUnits{};
  std::string currencyType{};
};

struct OptionDeliverables FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OptionDeliverablesT NativeTableType;
  typedef OptionDeliverablesBuilder Builder;
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "schwabMarketData.OptionDeliverables";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SYMBOL = 4,
    VT_ASSETTYPE = 6,
    VT_DELIVERABLEUNITS = 8,
    VT_CURRENCYTYPE = 10
  };
  const ::flatbuffers::String *symbol() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SYMBOL);
  }
  ::flatbuffers::String *mutable_symbol() {
    return GetPointer<::flatbuffers::String *>(VT_SYMBOL);
  }
  const ::flatbuffers::String *assetType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ASSETTYPE);
  }
  ::flatbuffers::String *mutable_assetType() {
    return GetPointer<::flatbuffers::String *>(VT_ASSETTYPE);
  }
  const ::flatbuffers::String *deliverableUnits() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DELIVERABLEUNITS);
  }
  ::flatbuffers::String *mutable_deliverableUnits() {
    return GetPointer<::flatbuffers::String *>(VT_DELIVERABLEUNITS);
  }
  const ::flatbuffers::String *currencyType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CURRENCYTYPE);
  }
  ::flatbuffers::String *mutable_currencyType() {
    return GetPointer<::flatbuffers::String *>(VT_CURRENCYTYPE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SYMBOL) &&
           verifier.VerifyString(symbol()) &&
           VerifyOffset(verifier, VT_ASSETTYPE) &&
           verifier.VerifyString(assetType()) &&
           VerifyOffset(verifier, VT_DELIVERABLEUNITS) &&
           verifier.VerifyString(deliverableUnits()) &&
           VerifyOffset(verifier, VT_CURRENCYTYPE) &&
           verifier.VerifyString(currencyType()) &&
           verifier.EndTable();
  }
  OptionDeliverablesT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OptionDeliverablesT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<OptionDeliverables> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const OptionDeliverablesT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OptionDeliverablesBuilder {
  typedef OptionDeliverables Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_symbol(::flatbuffers::Offset<::flatbuffers::String> symbol) {
    fbb_.AddOffset(OptionDeliverables::VT_SYMBOL, symbol);
  }
  void add_assetType(::flatbuffers::Offset<::flatbuffers::String> assetType) {
    fbb_.AddOffset(OptionDeliverables::VT_ASSETTYPE, assetType);
  }
  void add_deliverableUnits(::flatbuffers::Offset<::flatbuffers::String> deliverableUnits) {
    fbb_.AddOffset(OptionDeliverables::VT_DELIVERABLEUNITS, deliverableUnits);
  }
  void add_currencyType(::flatbuffers::Offset<::flatbuffers::String> currencyType) {
    fbb_.AddOffset(OptionDeliverables::VT_CURRENCYTYPE, currencyType);
  }
  explicit OptionDeliverablesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OptionDeliverables> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OptionDeliverables>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OptionDeliverables> CreateOptionDeliverables(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> symbol = 0,
    ::flatbuffers::Offset<::flatbuffers::String> assetType = 0,
    ::flatbuffers::Offset<::flatbuffers::String> deliverableUnits = 0,
    ::flatbuffers::Offset<::flatbuffers::String> currencyType = 0) {
  OptionDeliverablesBuilder builder_(_fbb);
  builder_.add_currencyType(currencyType);
  builder_.add_deliverableUnits(deliverableUnits);
  builder_.add_assetType(assetType);
  builder_.add_symbol(symbol);
  return builder_.Finish();
}

struct OptionDeliverables::Traits {
  using type = OptionDeliverables;
  static auto constexpr Create = CreateOptionDeliverables;
};

inline ::flatbuffers::Offset<OptionDeliverables> CreateOptionDeliverablesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *symbol = nullptr,
    const char *assetType = nullptr,
    const char *deliverableUnits = nullptr,
    const char *currencyType = nullptr) {
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  auto assetType__ = assetType ? _fbb.CreateString(assetType) : 0;
  auto deliverableUnits__ = deliverableUnits ? _fbb.CreateString(deliverableUnits) : 0;
  auto currencyType__ = currencyType ? _fbb.CreateString(currencyType) : 0;
  return schwabMarketData::CreateOptionDeliverables(
      _fbb,
      symbol__,
      assetType__,
      deliverableUnits__,
      currencyType__);
}

::flatbuffers::Offset<OptionDeliverables> CreateOptionDeliverables(::flatbuffers::FlatBufferBuilder &_fbb, const OptionDeliverablesT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OptionContractT : public ::flatbuffers::NativeTable {
  typedef OptionContract TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "schwabMarketData.OptionContractT";
  }
  schwabMarketData::PutCall putCall = schwabMarketData::PutCall::PUT;
  std::string symbol{};
  std::string description{};
  std::string exchangeName{};
  double bidPrice = 0.0;
  double askPrice = 0.0;
  double lastPrice = 0.0;
  double markPrice = 0.0;
  int32_t bidSize = 0;
  int32_t askSize = 0;
  int32_t lastSize = 0;
  double highPrice = 0.0;
  double lowPrice = 0.0;
  double openPrice = 0.0;
  double closePrice = 0.0;
  int32_t totalVolume = 0;
  int32_t tradeDate = 0;
  int32_t quoteTimeInLong = 0;
  int32_t tradeTimeInLong = 0;
  double netChange = 0.0;
  double volatility = 0.0;
  double delta = 0.0;
  double gamma = 0.0;
  double theta = 0.0;
  double vega = 0.0;
  double rho = 0.0;
  double timeValue = 0.0;
  double openInterest = 0.0;
  bool isInTheMoney = false;
  double theoreticalOptionValue = 0.0;
  double theoreticalVolatility = 0.0;
  bool isMini = false;
  bool isNonStandard = false;
  std::vector<std::unique_ptr<schwabMarketData::OptionDeliverablesT>> optionDeliverablesList{};
  double strikePrice = 0.0;
  std::string expirationDate{};
  int32_t daysToExpiration = 0;
  schwabMarketData::ExpirationType expirationType = schwabMarketData::ExpirationType::M;
  int64_t lastTradingDay = 0;
  double multiplier = 0.0;
  schwabMarketData::SettlementType settlementType = schwabMarketData::SettlementType::A;
  std::string deliverableNote{};
  bool isIndexOption = false;
  double percentChange = 0.0;
  double markChange = 0.0;
  double markPercentChange = 0.0;
  bool isPennyPilot = false;
  double intrinsicValue = 0.0;
  std::string optionRoot{};
  OptionContractT() = default;
  OptionContractT(const OptionContractT &o);
  OptionContractT(OptionContractT&&) FLATBUFFERS_NOEXCEPT = default;
  OptionContractT &operator=(OptionContractT o) FLATBUFFERS_NOEXCEPT;
};

struct OptionContract FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OptionContractT NativeTableType;
  typedef OptionContractBuilder Builder;
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "schwabMarketData.OptionContract";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PUTCALL = 4,
    VT_SYMBOL = 6,
    VT_DESCRIPTION = 8,
    VT_EXCHANGENAME = 10,
    VT_BIDPRICE = 12,
    VT_ASKPRICE = 14,
    VT_LASTPRICE = 16,
    VT_MARKPRICE = 18,
    VT_BIDSIZE = 20,
    VT_ASKSIZE = 22,
    VT_LASTSIZE = 24,
    VT_HIGHPRICE = 26,
    VT_LOWPRICE = 28,
    VT_OPENPRICE = 30,
    VT_CLOSEPRICE = 32,
    VT_TOTALVOLUME = 34,
    VT_TRADEDATE = 36,
    VT_QUOTETIMEINLONG = 38,
    VT_TRADETIMEINLONG = 40,
    VT_NETCHANGE = 42,
    VT_VOLATILITY = 44,
    VT_DELTA = 46,
    VT_GAMMA = 48,
    VT_THETA = 50,
    VT_VEGA = 52,
    VT_RHO = 54,
    VT_TIMEVALUE = 56,
    VT_OPENINTEREST = 58,
    VT_ISINTHEMONEY = 60,
    VT_THEORETICALOPTIONVALUE = 62,
    VT_THEORETICALVOLATILITY = 64,
    VT_ISMINI = 66,
    VT_ISNONSTANDARD = 68,
    VT_OPTIONDELIVERABLESLIST = 70,
    VT_STRIKEPRICE = 72,
    VT_EXPIRATIONDATE = 74,
    VT_DAYSTOEXPIRATION = 76,
    VT_EXPIRATIONTYPE = 78,
    VT_LASTTRADINGDAY = 80,
    VT_MULTIPLIER = 82,
    VT_SETTLEMENTTYPE = 84,
    VT_DELIVERABLENOTE = 86,
    VT_ISINDEXOPTION = 88,
    VT_PERCENTCHANGE = 90,
    VT_MARKCHANGE = 92,
    VT_MARKPERCENTCHANGE = 94,
    VT_ISPENNYPILOT = 96,
    VT_INTRINSICVALUE = 98,
    VT_OPTIONROOT = 100
  };
  schwabMarketData::PutCall putCall() const {
    return static_cast<schwabMarketData::PutCall>(GetField<int8_t>(VT_PUTCALL, 0));
  }
  bool mutate_putCall(schwabMarketData::PutCall _putCall = static_cast<schwabMarketData::PutCall>(0)) {
    return SetField<int8_t>(VT_PUTCALL, static_cast<int8_t>(_putCall), 0);
  }
  const ::flatbuffers::String *symbol() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SYMBOL);
  }
  ::flatbuffers::String *mutable_symbol() {
    return GetPointer<::flatbuffers::String *>(VT_SYMBOL);
  }
  const ::flatbuffers::String *description() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  ::flatbuffers::String *mutable_description() {
    return GetPointer<::flatbuffers::String *>(VT_DESCRIPTION);
  }
  const ::flatbuffers::String *exchangeName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EXCHANGENAME);
  }
  ::flatbuffers::String *mutable_exchangeName() {
    return GetPointer<::flatbuffers::String *>(VT_EXCHANGENAME);
  }
  double bidPrice() const {
    return GetField<double>(VT_BIDPRICE, 0.0);
  }
  bool mutate_bidPrice(double _bidPrice = 0.0) {
    return SetField<double>(VT_BIDPRICE, _bidPrice, 0.0);
  }
  double askPrice() const {
    return GetField<double>(VT_ASKPRICE, 0.0);
  }
  bool mutate_askPrice(double _askPrice = 0.0) {
    return SetField<double>(VT_ASKPRICE, _askPrice, 0.0);
  }
  double lastPrice() const {
    return GetField<double>(VT_LASTPRICE, 0.0);
  }
  bool mutate_lastPrice(double _lastPrice = 0.0) {
    return SetField<double>(VT_LASTPRICE, _lastPrice, 0.0);
  }
  double markPrice() const {
    return GetField<double>(VT_MARKPRICE, 0.0);
  }
  bool mutate_markPrice(double _markPrice = 0.0) {
    return SetField<double>(VT_MARKPRICE, _markPrice, 0.0);
  }
  int32_t bidSize() const {
    return GetField<int32_t>(VT_BIDSIZE, 0);
  }
  bool mutate_bidSize(int32_t _bidSize = 0) {
    return SetField<int32_t>(VT_BIDSIZE, _bidSize, 0);
  }
  int32_t askSize() const {
    return GetField<int32_t>(VT_ASKSIZE, 0);
  }
  bool mutate_askSize(int32_t _askSize = 0) {
    return SetField<int32_t>(VT_ASKSIZE, _askSize, 0);
  }
  int32_t lastSize() const {
    return GetField<int32_t>(VT_LASTSIZE, 0);
  }
  bool mutate_lastSize(int32_t _lastSize = 0) {
    return SetField<int32_t>(VT_LASTSIZE, _lastSize, 0);
  }
  double highPrice() const {
    return GetField<double>(VT_HIGHPRICE, 0.0);
  }
  bool mutate_highPrice(double _highPrice = 0.0) {
    return SetField<double>(VT_HIGHPRICE, _highPrice, 0.0);
  }
  double lowPrice() const {
    return GetField<double>(VT_LOWPRICE, 0.0);
  }
  bool mutate_lowPrice(double _lowPrice = 0.0) {
    return SetField<double>(VT_LOWPRICE, _lowPrice, 0.0);
  }
  double openPrice() const {
    return GetField<double>(VT_OPENPRICE, 0.0);
  }
  bool mutate_openPrice(double _openPrice = 0.0) {
    return SetField<double>(VT_OPENPRICE, _openPrice, 0.0);
  }
  double closePrice() const {
    return GetField<double>(VT_CLOSEPRICE, 0.0);
  }
  bool mutate_closePrice(double _closePrice = 0.0) {
    return SetField<double>(VT_CLOSEPRICE, _closePrice, 0.0);
  }
  int32_t totalVolume() const {
    return GetField<int32_t>(VT_TOTALVOLUME, 0);
  }
  bool mutate_totalVolume(int32_t _totalVolume = 0) {
    return SetField<int32_t>(VT_TOTALVOLUME, _totalVolume, 0);
  }
  int32_t tradeDate() const {
    return GetField<int32_t>(VT_TRADEDATE, 0);
  }
  bool mutate_tradeDate(int32_t _tradeDate = 0) {
    return SetField<int32_t>(VT_TRADEDATE, _tradeDate, 0);
  }
  int32_t quoteTimeInLong() const {
    return GetField<int32_t>(VT_QUOTETIMEINLONG, 0);
  }
  bool mutate_quoteTimeInLong(int32_t _quoteTimeInLong = 0) {
    return SetField<int32_t>(VT_QUOTETIMEINLONG, _quoteTimeInLong, 0);
  }
  int32_t tradeTimeInLong() const {
    return GetField<int32_t>(VT_TRADETIMEINLONG, 0);
  }
  bool mutate_tradeTimeInLong(int32_t _tradeTimeInLong = 0) {
    return SetField<int32_t>(VT_TRADETIMEINLONG, _tradeTimeInLong, 0);
  }
  double netChange() const {
    return GetField<double>(VT_NETCHANGE, 0.0);
  }
  bool mutate_netChange(double _netChange = 0.0) {
    return SetField<double>(VT_NETCHANGE, _netChange, 0.0);
  }
  double volatility() const {
    return GetField<double>(VT_VOLATILITY, 0.0);
  }
  bool mutate_volatility(double _volatility = 0.0) {
    return SetField<double>(VT_VOLATILITY, _volatility, 0.0);
  }
  double delta() const {
    return GetField<double>(VT_DELTA, 0.0);
  }
  bool mutate_delta(double _delta = 0.0) {
    return SetField<double>(VT_DELTA, _delta, 0.0);
  }
  double gamma() const {
    return GetField<double>(VT_GAMMA, 0.0);
  }
  bool mutate_gamma(double _gamma = 0.0) {
    return SetField<double>(VT_GAMMA, _gamma, 0.0);
  }
  double theta() const {
    return GetField<double>(VT_THETA, 0.0);
  }
  bool mutate_theta(double _theta = 0.0) {
    return SetField<double>(VT_THETA, _theta, 0.0);
  }
  double vega() const {
    return GetField<double>(VT_VEGA, 0.0);
  }
  bool mutate_vega(double _vega = 0.0) {
    return SetField<double>(VT_VEGA, _vega, 0.0);
  }
  double rho() const {
    return GetField<double>(VT_RHO, 0.0);
  }
  bool mutate_rho(double _rho = 0.0) {
    return SetField<double>(VT_RHO, _rho, 0.0);
  }
  double timeValue() const {
    return GetField<double>(VT_TIMEVALUE, 0.0);
  }
  bool mutate_timeValue(double _timeValue = 0.0) {
    return SetField<double>(VT_TIMEVALUE, _timeValue, 0.0);
  }
  double openInterest() const {
    return GetField<double>(VT_OPENINTEREST, 0.0);
  }
  bool mutate_openInterest(double _openInterest = 0.0) {
    return SetField<double>(VT_OPENINTEREST, _openInterest, 0.0);
  }
  bool isInTheMoney() const {
    return GetField<uint8_t>(VT_ISINTHEMONEY, 0) != 0;
  }
  bool mutate_isInTheMoney(bool _isInTheMoney = 0) {
    return SetField<uint8_t>(VT_ISINTHEMONEY, static_cast<uint8_t>(_isInTheMoney), 0);
  }
  double theoreticalOptionValue() const {
    return GetField<double>(VT_THEORETICALOPTIONVALUE, 0.0);
  }
  bool mutate_theoreticalOptionValue(double _theoreticalOptionValue = 0.0) {
    return SetField<double>(VT_THEORETICALOPTIONVALUE, _theoreticalOptionValue, 0.0);
  }
  double theoreticalVolatility() const {
    return GetField<double>(VT_THEORETICALVOLATILITY, 0.0);
  }
  bool mutate_theoreticalVolatility(double _theoreticalVolatility = 0.0) {
    return SetField<double>(VT_THEORETICALVOLATILITY, _theoreticalVolatility, 0.0);
  }
  bool isMini() const {
    return GetField<uint8_t>(VT_ISMINI, 0) != 0;
  }
  bool mutate_isMini(bool _isMini = 0) {
    return SetField<uint8_t>(VT_ISMINI, static_cast<uint8_t>(_isMini), 0);
  }
  bool isNonStandard() const {
    return GetField<uint8_t>(VT_ISNONSTANDARD, 0) != 0;
  }
  bool mutate_isNonStandard(bool _isNonStandard = 0) {
    return SetField<uint8_t>(VT_ISNONSTANDARD, static_cast<uint8_t>(_isNonStandard), 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<schwabMarketData::OptionDeliverables>> *optionDeliverablesList() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<schwabMarketData::OptionDeliverables>> *>(VT_OPTIONDELIVERABLESLIST);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<schwabMarketData::OptionDeliverables>> *mutable_optionDeliverablesList() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<schwabMarketData::OptionDeliverables>> *>(VT_OPTIONDELIVERABLESLIST);
  }
  double strikePrice() const {
    return GetField<double>(VT_STRIKEPRICE, 0.0);
  }
  bool mutate_strikePrice(double _strikePrice = 0.0) {
    return SetField<double>(VT_STRIKEPRICE, _strikePrice, 0.0);
  }
  const ::flatbuffers::String *expirationDate() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EXPIRATIONDATE);
  }
  ::flatbuffers::String *mutable_expirationDate() {
    return GetPointer<::flatbuffers::String *>(VT_EXPIRATIONDATE);
  }
  int32_t daysToExpiration() const {
    return GetField<int32_t>(VT_DAYSTOEXPIRATION, 0);
  }
  bool mutate_daysToExpiration(int32_t _daysToExpiration = 0) {
    return SetField<int32_t>(VT_DAYSTOEXPIRATION, _daysToExpiration, 0);
  }
  schwabMarketData::ExpirationType expirationType() const {
    return static_cast<schwabMarketData::ExpirationType>(GetField<int8_t>(VT_EXPIRATIONTYPE, 0));
  }
  bool mutate_expirationType(schwabMarketData::ExpirationType _expirationType = static_cast<schwabMarketData::ExpirationType>(0)) {
    return SetField<int8_t>(VT_EXPIRATIONTYPE, static_cast<int8_t>(_expirationType), 0);
  }
  int64_t lastTradingDay() const {
    return GetField<int64_t>(VT_LASTTRADINGDAY, 0);
  }
  bool mutate_lastTradingDay(int64_t _lastTradingDay = 0) {
    return SetField<int64_t>(VT_LASTTRADINGDAY, _lastTradingDay, 0);
  }
  double multiplier() const {
    return GetField<double>(VT_MULTIPLIER, 0.0);
  }
  bool mutate_multiplier(double _multiplier = 0.0) {
    return SetField<double>(VT_MULTIPLIER, _multiplier, 0.0);
  }
  schwabMarketData::SettlementType settlementType() const {
    return static_cast<schwabMarketData::SettlementType>(GetField<int8_t>(VT_SETTLEMENTTYPE, 0));
  }
  bool mutate_settlementType(schwabMarketData::SettlementType _settlementType = static_cast<schwabMarketData::SettlementType>(0)) {
    return SetField<int8_t>(VT_SETTLEMENTTYPE, static_cast<int8_t>(_settlementType), 0);
  }
  const ::flatbuffers::String *deliverableNote() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DELIVERABLENOTE);
  }
  ::flatbuffers::String *mutable_deliverableNote() {
    return GetPointer<::flatbuffers::String *>(VT_DELIVERABLENOTE);
  }
  bool isIndexOption() const {
    return GetField<uint8_t>(VT_ISINDEXOPTION, 0) != 0;
  }
  bool mutate_isIndexOption(bool _isIndexOption = 0) {
    return SetField<uint8_t>(VT_ISINDEXOPTION, static_cast<uint8_t>(_isIndexOption), 0);
  }
  double percentChange() const {
    return GetField<double>(VT_PERCENTCHANGE, 0.0);
  }
  bool mutate_percentChange(double _percentChange = 0.0) {
    return SetField<double>(VT_PERCENTCHANGE, _percentChange, 0.0);
  }
  double markChange() const {
    return GetField<double>(VT_MARKCHANGE, 0.0);
  }
  bool mutate_markChange(double _markChange = 0.0) {
    return SetField<double>(VT_MARKCHANGE, _markChange, 0.0);
  }
  double markPercentChange() const {
    return GetField<double>(VT_MARKPERCENTCHANGE, 0.0);
  }
  bool mutate_markPercentChange(double _markPercentChange = 0.0) {
    return SetField<double>(VT_MARKPERCENTCHANGE, _markPercentChange, 0.0);
  }
  bool isPennyPilot() const {
    return GetField<uint8_t>(VT_ISPENNYPILOT, 0) != 0;
  }
  bool mutate_isPennyPilot(bool _isPennyPilot = 0) {
    return SetField<uint8_t>(VT_ISPENNYPILOT, static_cast<uint8_t>(_isPennyPilot), 0);
  }
  double intrinsicValue() const {
    return GetField<double>(VT_INTRINSICVALUE, 0.0);
  }
  bool mutate_intrinsicValue(double _intrinsicValue = 0.0) {
    return SetField<double>(VT_INTRINSICVALUE, _intrinsicValue, 0.0);
  }
  const ::flatbuffers::String *optionRoot() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OPTIONROOT);
  }
  ::flatbuffers::String *mutable_optionRoot() {
    return GetPointer<::flatbuffers::String *>(VT_OPTIONROOT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_PUTCALL, 1) &&
           VerifyOffset(verifier, VT_SYMBOL) &&
           verifier.VerifyString(symbol()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           VerifyOffset(verifier, VT_EXCHANGENAME) &&
           verifier.VerifyString(exchangeName()) &&
           VerifyField<double>(verifier, VT_BIDPRICE, 8) &&
           VerifyField<double>(verifier, VT_ASKPRICE, 8) &&
           VerifyField<double>(verifier, VT_LASTPRICE, 8) &&
           VerifyField<double>(verifier, VT_MARKPRICE, 8) &&
           VerifyField<int32_t>(verifier, VT_BIDSIZE, 4) &&
           VerifyField<int32_t>(verifier, VT_ASKSIZE, 4) &&
           VerifyField<int32_t>(verifier, VT_LASTSIZE, 4) &&
           VerifyField<double>(verifier, VT_HIGHPRICE, 8) &&
           VerifyField<double>(verifier, VT_LOWPRICE, 8) &&
           VerifyField<double>(verifier, VT_OPENPRICE, 8) &&
           VerifyField<double>(verifier, VT_CLOSEPRICE, 8) &&
           VerifyField<int32_t>(verifier, VT_TOTALVOLUME, 4) &&
           VerifyField<int32_t>(verifier, VT_TRADEDATE, 4) &&
           VerifyField<int32_t>(verifier, VT_QUOTETIMEINLONG, 4) &&
           VerifyField<int32_t>(verifier, VT_TRADETIMEINLONG, 4) &&
           VerifyField<double>(verifier, VT_NETCHANGE, 8) &&
           VerifyField<double>(verifier, VT_VOLATILITY, 8) &&
           VerifyField<double>(verifier, VT_DELTA, 8) &&
           VerifyField<double>(verifier, VT_GAMMA, 8) &&
           VerifyField<double>(verifier, VT_THETA, 8) &&
           VerifyField<double>(verifier, VT_VEGA, 8) &&
           VerifyField<double>(verifier, VT_RHO, 8) &&
           VerifyField<double>(verifier, VT_TIMEVALUE, 8) &&
           VerifyField<double>(verifier, VT_OPENINTEREST, 8) &&
           VerifyField<uint8_t>(verifier, VT_ISINTHEMONEY, 1) &&
           VerifyField<double>(verifier, VT_THEORETICALOPTIONVALUE, 8) &&
           VerifyField<double>(verifier, VT_THEORETICALVOLATILITY, 8) &&
           VerifyField<uint8_t>(verifier, VT_ISMINI, 1) &&
           VerifyField<uint8_t>(verifier, VT_ISNONSTANDARD, 1) &&
           VerifyOffset(verifier, VT_OPTIONDELIVERABLESLIST) &&
           verifier.VerifyVector(optionDeliverablesList()) &&
           verifier.VerifyVectorOfTables(optionDeliverablesList()) &&
           VerifyField<double>(verifier, VT_STRIKEPRICE, 8) &&
           VerifyOffset(verifier, VT_EXPIRATIONDATE) &&
           verifier.VerifyString(expirationDate()) &&
           VerifyField<int32_t>(verifier, VT_DAYSTOEXPIRATION, 4) &&
           VerifyField<int8_t>(verifier, VT_EXPIRATIONTYPE, 1) &&
           VerifyField<int64_t>(verifier, VT_LASTTRADINGDAY, 8) &&
           VerifyField<double>(verifier, VT_MULTIPLIER, 8) &&
           VerifyField<int8_t>(verifier, VT_SETTLEMENTTYPE, 1) &&
           VerifyOffset(verifier, VT_DELIVERABLENOTE) &&
           verifier.VerifyString(deliverableNote()) &&
           VerifyField<uint8_t>(verifier, VT_ISINDEXOPTION, 1) &&
           VerifyField<double>(verifier, VT_PERCENTCHANGE, 8) &&
           VerifyField<double>(verifier, VT_MARKCHANGE, 8) &&
           VerifyField<double>(verifier, VT_MARKPERCENTCHANGE, 8) &&
           VerifyField<uint8_t>(verifier, VT_ISPENNYPILOT, 1) &&
           VerifyField<double>(verifier, VT_INTRINSICVALUE, 8) &&
           VerifyOffset(verifier, VT_OPTIONROOT) &&
           verifier.VerifyString(optionRoot()) &&
           verifier.EndTable();
  }
  OptionContractT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OptionContractT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<OptionContract> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const OptionContractT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OptionContractBuilder {
  typedef OptionContract Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_putCall(schwabMarketData::PutCall putCall) {
    fbb_.AddElement<int8_t>(OptionContract::VT_PUTCALL, static_cast<int8_t>(putCall), 0);
  }
  void add_symbol(::flatbuffers::Offset<::flatbuffers::String> symbol) {
    fbb_.AddOffset(OptionContract::VT_SYMBOL, symbol);
  }
  void add_description(::flatbuffers::Offset<::flatbuffers::String> description) {
    fbb_.AddOffset(OptionContract::VT_DESCRIPTION, description);
  }
  void add_exchangeName(::flatbuffers::Offset<::flatbuffers::String> exchangeName) {
    fbb_.AddOffset(OptionContract::VT_EXCHANGENAME, exchangeName);
  }
  void add_bidPrice(double bidPrice) {
    fbb_.AddElement<double>(OptionContract::VT_BIDPRICE, bidPrice, 0.0);
  }
  void add_askPrice(double askPrice) {
    fbb_.AddElement<double>(OptionContract::VT_ASKPRICE, askPrice, 0.0);
  }
  void add_lastPrice(double lastPrice) {
    fbb_.AddElement<double>(OptionContract::VT_LASTPRICE, lastPrice, 0.0);
  }
  void add_markPrice(double markPrice) {
    fbb_.AddElement<double>(OptionContract::VT_MARKPRICE, markPrice, 0.0);
  }
  void add_bidSize(int32_t bidSize) {
    fbb_.AddElement<int32_t>(OptionContract::VT_BIDSIZE, bidSize, 0);
  }
  void add_askSize(int32_t askSize) {
    fbb_.AddElement<int32_t>(OptionContract::VT_ASKSIZE, askSize, 0);
  }
  void add_lastSize(int32_t lastSize) {
    fbb_.AddElement<int32_t>(OptionContract::VT_LASTSIZE, lastSize, 0);
  }
  void add_highPrice(double highPrice) {
    fbb_.AddElement<double>(OptionContract::VT_HIGHPRICE, highPrice, 0.0);
  }
  void add_lowPrice(double lowPrice) {
    fbb_.AddElement<double>(OptionContract::VT_LOWPRICE, lowPrice, 0.0);
  }
  void add_openPrice(double openPrice) {
    fbb_.AddElement<double>(OptionContract::VT_OPENPRICE, openPrice, 0.0);
  }
  void add_closePrice(double closePrice) {
    fbb_.AddElement<double>(OptionContract::VT_CLOSEPRICE, closePrice, 0.0);
  }
  void add_totalVolume(int32_t totalVolume) {
    fbb_.AddElement<int32_t>(OptionContract::VT_TOTALVOLUME, totalVolume, 0);
  }
  void add_tradeDate(int32_t tradeDate) {
    fbb_.AddElement<int32_t>(OptionContract::VT_TRADEDATE, tradeDate, 0);
  }
  void add_quoteTimeInLong(int32_t quoteTimeInLong) {
    fbb_.AddElement<int32_t>(OptionContract::VT_QUOTETIMEINLONG, quoteTimeInLong, 0);
  }
  void add_tradeTimeInLong(int32_t tradeTimeInLong) {
    fbb_.AddElement<int32_t>(OptionContract::VT_TRADETIMEINLONG, tradeTimeInLong, 0);
  }
  void add_netChange(double netChange) {
    fbb_.AddElement<double>(OptionContract::VT_NETCHANGE, netChange, 0.0);
  }
  void add_volatility(double volatility) {
    fbb_.AddElement<double>(OptionContract::VT_VOLATILITY, volatility, 0.0);
  }
  void add_delta(double delta) {
    fbb_.AddElement<double>(OptionContract::VT_DELTA, delta, 0.0);
  }
  void add_gamma(double gamma) {
    fbb_.AddElement<double>(OptionContract::VT_GAMMA, gamma, 0.0);
  }
  void add_theta(double theta) {
    fbb_.AddElement<double>(OptionContract::VT_THETA, theta, 0.0);
  }
  void add_vega(double vega) {
    fbb_.AddElement<double>(OptionContract::VT_VEGA, vega, 0.0);
  }
  void add_rho(double rho) {
    fbb_.AddElement<double>(OptionContract::VT_RHO, rho, 0.0);
  }
  void add_timeValue(double timeValue) {
    fbb_.AddElement<double>(OptionContract::VT_TIMEVALUE, timeValue, 0.0);
  }
  void add_openInterest(double openInterest) {
    fbb_.AddElement<double>(OptionContract::VT_OPENINTEREST, openInterest, 0.0);
  }
  void add_isInTheMoney(bool isInTheMoney) {
    fbb_.AddElement<uint8_t>(OptionContract::VT_ISINTHEMONEY, static_cast<uint8_t>(isInTheMoney), 0);
  }
  void add_theoreticalOptionValue(double theoreticalOptionValue) {
    fbb_.AddElement<double>(OptionContract::VT_THEORETICALOPTIONVALUE, theoreticalOptionValue, 0.0);
  }
  void add_theoreticalVolatility(double theoreticalVolatility) {
    fbb_.AddElement<double>(OptionContract::VT_THEORETICALVOLATILITY, theoreticalVolatility, 0.0);
  }
  void add_isMini(bool isMini) {
    fbb_.AddElement<uint8_t>(OptionContract::VT_ISMINI, static_cast<uint8_t>(isMini), 0);
  }
  void add_isNonStandard(bool isNonStandard) {
    fbb_.AddElement<uint8_t>(OptionContract::VT_ISNONSTANDARD, static_cast<uint8_t>(isNonStandard), 0);
  }
  void add_optionDeliverablesList(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<schwabMarketData::OptionDeliverables>>> optionDeliverablesList) {
    fbb_.AddOffset(OptionContract::VT_OPTIONDELIVERABLESLIST, optionDeliverablesList);
  }
  void add_strikePrice(double strikePrice) {
    fbb_.AddElement<double>(OptionContract::VT_STRIKEPRICE, strikePrice, 0.0);
  }
  void add_expirationDate(::flatbuffers::Offset<::flatbuffers::String> expirationDate) {
    fbb_.AddOffset(OptionContract::VT_EXPIRATIONDATE, expirationDate);
  }
  void add_daysToExpiration(int32_t daysToExpiration) {
    fbb_.AddElement<int32_t>(OptionContract::VT_DAYSTOEXPIRATION, daysToExpiration, 0);
  }
  void add_expirationType(schwabMarketData::ExpirationType expirationType) {
    fbb_.AddElement<int8_t>(OptionContract::VT_EXPIRATIONTYPE, static_cast<int8_t>(expirationType), 0);
  }
  void add_lastTradingDay(int64_t lastTradingDay) {
    fbb_.AddElement<int64_t>(OptionContract::VT_LASTTRADINGDAY, lastTradingDay, 0);
  }
  void add_multiplier(double multiplier) {
    fbb_.AddElement<double>(OptionContract::VT_MULTIPLIER, multiplier, 0.0);
  }
  void add_settlementType(schwabMarketData::SettlementType settlementType) {
    fbb_.AddElement<int8_t>(OptionContract::VT_SETTLEMENTTYPE, static_cast<int8_t>(settlementType), 0);
  }
  void add_deliverableNote(::flatbuffers::Offset<::flatbuffers::String> deliverableNote) {
    fbb_.AddOffset(OptionContract::VT_DELIVERABLENOTE, deliverableNote);
  }
  void add_isIndexOption(bool isIndexOption) {
    fbb_.AddElement<uint8_t>(OptionContract::VT_ISINDEXOPTION, static_cast<uint8_t>(isIndexOption), 0);
  }
  void add_percentChange(double percentChange) {
    fbb_.AddElement<double>(OptionContract::VT_PERCENTCHANGE, percentChange, 0.0);
  }
  void add_markChange(double markChange) {
    fbb_.AddElement<double>(OptionContract::VT_MARKCHANGE, markChange, 0.0);
  }
  void add_markPercentChange(double markPercentChange) {
    fbb_.AddElement<double>(OptionContract::VT_MARKPERCENTCHANGE, markPercentChange, 0.0);
  }
  void add_isPennyPilot(bool isPennyPilot) {
    fbb_.AddElement<uint8_t>(OptionContract::VT_ISPENNYPILOT, static_cast<uint8_t>(isPennyPilot), 0);
  }
  void add_intrinsicValue(double intrinsicValue) {
    fbb_.AddElement<double>(OptionContract::VT_INTRINSICVALUE, intrinsicValue, 0.0);
  }
  void add_optionRoot(::flatbuffers::Offset<::flatbuffers::String> optionRoot) {
    fbb_.AddOffset(OptionContract::VT_OPTIONROOT, optionRoot);
  }
  explicit OptionContractBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OptionContract> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OptionContract>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OptionContract> CreateOptionContract(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    schwabMarketData::PutCall putCall = schwabMarketData::PutCall::PUT,
    ::flatbuffers::Offset<::flatbuffers::String> symbol = 0,
    ::flatbuffers::Offset<::flatbuffers::String> description = 0,
    ::flatbuffers::Offset<::flatbuffers::String> exchangeName = 0,
    double bidPrice = 0.0,
    double askPrice = 0.0,
    double lastPrice = 0.0,
    double markPrice = 0.0,
    int32_t bidSize = 0,
    int32_t askSize = 0,
    int32_t lastSize = 0,
    double highPrice = 0.0,
    double lowPrice = 0.0,
    double openPrice = 0.0,
    double closePrice = 0.0,
    int32_t totalVolume = 0,
    int32_t tradeDate = 0,
    int32_t quoteTimeInLong = 0,
    int32_t tradeTimeInLong = 0,
    double netChange = 0.0,
    double volatility = 0.0,
    double delta = 0.0,
    double gamma = 0.0,
    double theta = 0.0,
    double vega = 0.0,
    double rho = 0.0,
    double timeValue = 0.0,
    double openInterest = 0.0,
    bool isInTheMoney = false,
    double theoreticalOptionValue = 0.0,
    double theoreticalVolatility = 0.0,
    bool isMini = false,
    bool isNonStandard = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<schwabMarketData::OptionDeliverables>>> optionDeliverablesList = 0,
    double strikePrice = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> expirationDate = 0,
    int32_t daysToExpiration = 0,
    schwabMarketData::ExpirationType expirationType = schwabMarketData::ExpirationType::M,
    int64_t lastTradingDay = 0,
    double multiplier = 0.0,
    schwabMarketData::SettlementType settlementType = schwabMarketData::SettlementType::A,
    ::flatbuffers::Offset<::flatbuffers::String> deliverableNote = 0,
    bool isIndexOption = false,
    double percentChange = 0.0,
    double markChange = 0.0,
    double markPercentChange = 0.0,
    bool isPennyPilot = false,
    double intrinsicValue = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> optionRoot = 0) {
  OptionContractBuilder builder_(_fbb);
  builder_.add_intrinsicValue(intrinsicValue);
  builder_.add_markPercentChange(markPercentChange);
  builder_.add_markChange(markChange);
  builder_.add_percentChange(percentChange);
  builder_.add_multiplier(multiplier);
  builder_.add_lastTradingDay(lastTradingDay);
  builder_.add_strikePrice(strikePrice);
  builder_.add_theoreticalVolatility(theoreticalVolatility);
  builder_.add_theoreticalOptionValue(theoreticalOptionValue);
  builder_.add_openInterest(openInterest);
  builder_.add_timeValue(timeValue);
  builder_.add_rho(rho);
  builder_.add_vega(vega);
  builder_.add_theta(theta);
  builder_.add_gamma(gamma);
  builder_.add_delta(delta);
  builder_.add_volatility(volatility);
  builder_.add_netChange(netChange);
  builder_.add_closePrice(closePrice);
  builder_.add_openPrice(openPrice);
  builder_.add_lowPrice(lowPrice);
  builder_.add_highPrice(highPrice);
  builder_.add_markPrice(markPrice);
  builder_.add_lastPrice(lastPrice);
  builder_.add_askPrice(askPrice);
  builder_.add_bidPrice(bidPrice);
  builder_.add_optionRoot(optionRoot);
  builder_.add_deliverableNote(deliverableNote);
  builder_.add_daysToExpiration(daysToExpiration);
  builder_.add_expirationDate(expirationDate);
  builder_.add_optionDeliverablesList(optionDeliverablesList);
  builder_.add_tradeTimeInLong(tradeTimeInLong);
  builder_.add_quoteTimeInLong(quoteTimeInLong);
  builder_.add_tradeDate(tradeDate);
  builder_.add_totalVolume(totalVolume);
  builder_.add_lastSize(lastSize);
  builder_.add_askSize(askSize);
  builder_.add_bidSize(bidSize);
  builder_.add_exchangeName(exchangeName);
  builder_.add_description(description);
  builder_.add_symbol(symbol);
  builder_.add_isPennyPilot(isPennyPilot);
  builder_.add_isIndexOption(isIndexOption);
  builder_.add_settlementType(settlementType);
  builder_.add_expirationType(expirationType);
  builder_.add_isNonStandard(isNonStandard);
  builder_.add_isMini(isMini);
  builder_.add_isInTheMoney(isInTheMoney);
  builder_.add_putCall(putCall);
  return builder_.Finish();
}

struct OptionContract::Traits {
  using type = OptionContract;
  static auto constexpr Create = CreateOptionContract;
};

inline ::flatbuffers::Offset<OptionContract> CreateOptionContractDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    schwabMarketData::PutCall putCall = schwabMarketData::PutCall::PUT,
    const char *symbol = nullptr,
    const char *description = nullptr,
    const char *exchangeName = nullptr,
    double bidPrice = 0.0,
    double askPrice = 0.0,
    double lastPrice = 0.0,
    double markPrice = 0.0,
    int32_t bidSize = 0,
    int32_t askSize = 0,
    int32_t lastSize = 0,
    double highPrice = 0.0,
    double lowPrice = 0.0,
    double openPrice = 0.0,
    double closePrice = 0.0,
    int32_t totalVolume = 0,
    int32_t tradeDate = 0,
    int32_t quoteTimeInLong = 0,
    int32_t tradeTimeInLong = 0,
    double netChange = 0.0,
    double volatility = 0.0,
    double delta = 0.0,
    double gamma = 0.0,
    double theta = 0.0,
    double vega = 0.0,
    double rho = 0.0,
    double timeValue = 0.0,
    double openInterest = 0.0,
    bool isInTheMoney = false,
    double theoreticalOptionValue = 0.0,
    double theoreticalVolatility = 0.0,
    bool isMini = false,
    bool isNonStandard = false,
    const std::vector<::flatbuffers::Offset<schwabMarketData::OptionDeliverables>> *optionDeliverablesList = nullptr,
    double strikePrice = 0.0,
    const char *expirationDate = nullptr,
    int32_t daysToExpiration = 0,
    schwabMarketData::ExpirationType expirationType = schwabMarketData::ExpirationType::M,
    int64_t lastTradingDay = 0,
    double multiplier = 0.0,
    schwabMarketData::SettlementType settlementType = schwabMarketData::SettlementType::A,
    const char *deliverableNote = nullptr,
    bool isIndexOption = false,
    double percentChange = 0.0,
    double markChange = 0.0,
    double markPercentChange = 0.0,
    bool isPennyPilot = false,
    double intrinsicValue = 0.0,
    const char *optionRoot = nullptr) {
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  auto description__ = description ? _fbb.CreateString(description) : 0;
  auto exchangeName__ = exchangeName ? _fbb.CreateString(exchangeName) : 0;
  auto optionDeliverablesList__ = optionDeliverablesList ? _fbb.CreateVector<::flatbuffers::Offset<schwabMarketData::OptionDeliverables>>(*optionDeliverablesList) : 0;
  auto expirationDate__ = expirationDate ? _fbb.CreateString(expirationDate) : 0;
  auto deliverableNote__ = deliverableNote ? _fbb.CreateString(deliverableNote) : 0;
  auto optionRoot__ = optionRoot ? _fbb.CreateString(optionRoot) : 0;
  return schwabMarketData::CreateOptionContract(
      _fbb,
      putCall,
      symbol__,
      description__,
      exchangeName__,
      bidPrice,
      askPrice,
      lastPrice,
      markPrice,
      bidSize,
      askSize,
      lastSize,
      highPrice,
      lowPrice,
      openPrice,
      closePrice,
      totalVolume,
      tradeDate,
      quoteTimeInLong,
      tradeTimeInLong,
      netChange,
      volatility,
      delta,
      gamma,
      theta,
      vega,
      rho,
      timeValue,
      openInterest,
      isInTheMoney,
      theoreticalOptionValue,
      theoreticalVolatility,
      isMini,
      isNonStandard,
      optionDeliverablesList__,
      strikePrice,
      expirationDate__,
      daysToExpiration,
      expirationType,
      lastTradingDay,
      multiplier,
      settlementType,
      deliverableNote__,
      isIndexOption,
      percentChange,
      markChange,
      markPercentChange,
      isPennyPilot,
      intrinsicValue,
      optionRoot__);
}

::flatbuffers::Offset<OptionContract> CreateOptionContract(::flatbuffers::FlatBufferBuilder &_fbb, const OptionContractT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OptionContractMapT : public ::flatbuffers::NativeTable {
  typedef OptionContractMap TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "schwabMarketData.OptionContractMapT";
  }
};

struct OptionContractMap FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OptionContractMapT NativeTableType;
  typedef OptionContractMapBuilder Builder;
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "schwabMarketData.OptionContractMap";
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  OptionContractMapT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OptionContractMapT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<OptionContractMap> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const OptionContractMapT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OptionContractMapBuilder {
  typedef OptionContractMap Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit OptionContractMapBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OptionContractMap> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OptionContractMap>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OptionContractMap> CreateOptionContractMap(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  OptionContractMapBuilder builder_(_fbb);
  return builder_.Finish();
}

struct OptionContractMap::Traits {
  using type = OptionContractMap;
  static auto constexpr Create = CreateOptionContractMap;
};

::flatbuffers::Offset<OptionContractMap> CreateOptionContractMap(::flatbuffers::FlatBufferBuilder &_fbb, const OptionContractMapT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OptionChainT : public ::flatbuffers::NativeTable {
  typedef OptionChain TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "schwabMarketData.OptionChainT";
  }
  std::string symbol{};
  std::string status{};
  std::unique_ptr<schwabMarketData::UnderlyingT> underlying{};
  schwabMarketData::OptionStrategy strategy = schwabMarketData::OptionStrategy::SINGLE;
  double interval = 0.0;
  bool isDelayed = false;
  bool isIndex = false;
  double daysToExpiration = 0.0;
  double interestRate = 0.0;
  double underlyingPrice = 0.0;
  double volatility = 0.0;
  std::unique_ptr<schwabMarketData::OptionContractT> callExpDateMap{};
  std::unique_ptr<schwabMarketData::OptionContractT> putExpDateMap{};
  OptionChainT() = default;
  OptionChainT(const OptionChainT &o);
  OptionChainT(OptionChainT&&) FLATBUFFERS_NOEXCEPT = default;
  OptionChainT &operator=(OptionChainT o) FLATBUFFERS_NOEXCEPT;
};

struct OptionChain FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OptionChainT NativeTableType;
  typedef OptionChainBuilder Builder;
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "schwabMarketData.OptionChain";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SYMBOL = 4,
    VT_STATUS = 6,
    VT_UNDERLYING = 8,
    VT_STRATEGY = 10,
    VT_INTERVAL = 12,
    VT_ISDELAYED = 14,
    VT_ISINDEX = 16,
    VT_DAYSTOEXPIRATION = 18,
    VT_INTERESTRATE = 20,
    VT_UNDERLYINGPRICE = 22,
    VT_VOLATILITY = 24,
    VT_CALLEXPDATEMAP = 26,
    VT_PUTEXPDATEMAP = 28
  };
  const ::flatbuffers::String *symbol() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SYMBOL);
  }
  ::flatbuffers::String *mutable_symbol() {
    return GetPointer<::flatbuffers::String *>(VT_SYMBOL);
  }
  const ::flatbuffers::String *status() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STATUS);
  }
  ::flatbuffers::String *mutable_status() {
    return GetPointer<::flatbuffers::String *>(VT_STATUS);
  }
  const schwabMarketData::Underlying *underlying() const {
    return GetPointer<const schwabMarketData::Underlying *>(VT_UNDERLYING);
  }
  schwabMarketData::Underlying *mutable_underlying() {
    return GetPointer<schwabMarketData::Underlying *>(VT_UNDERLYING);
  }
  schwabMarketData::OptionStrategy strategy() const {
    return static_cast<schwabMarketData::OptionStrategy>(GetField<int8_t>(VT_STRATEGY, 0));
  }
  bool mutate_strategy(schwabMarketData::OptionStrategy _strategy = static_cast<schwabMarketData::OptionStrategy>(0)) {
    return SetField<int8_t>(VT_STRATEGY, static_cast<int8_t>(_strategy), 0);
  }
  double interval() const {
    return GetField<double>(VT_INTERVAL, 0.0);
  }
  bool mutate_interval(double _interval = 0.0) {
    return SetField<double>(VT_INTERVAL, _interval, 0.0);
  }
  bool isDelayed() const {
    return GetField<uint8_t>(VT_ISDELAYED, 0) != 0;
  }
  bool mutate_isDelayed(bool _isDelayed = 0) {
    return SetField<uint8_t>(VT_ISDELAYED, static_cast<uint8_t>(_isDelayed), 0);
  }
  bool isIndex() const {
    return GetField<uint8_t>(VT_ISINDEX, 0) != 0;
  }
  bool mutate_isIndex(bool _isIndex = 0) {
    return SetField<uint8_t>(VT_ISINDEX, static_cast<uint8_t>(_isIndex), 0);
  }
  double daysToExpiration() const {
    return GetField<double>(VT_DAYSTOEXPIRATION, 0.0);
  }
  bool mutate_daysToExpiration(double _daysToExpiration = 0.0) {
    return SetField<double>(VT_DAYSTOEXPIRATION, _daysToExpiration, 0.0);
  }
  double interestRate() const {
    return GetField<double>(VT_INTERESTRATE, 0.0);
  }
  bool mutate_interestRate(double _interestRate = 0.0) {
    return SetField<double>(VT_INTERESTRATE, _interestRate, 0.0);
  }
  double underlyingPrice() const {
    return GetField<double>(VT_UNDERLYINGPRICE, 0.0);
  }
  bool mutate_underlyingPrice(double _underlyingPrice = 0.0) {
    return SetField<double>(VT_UNDERLYINGPRICE, _underlyingPrice, 0.0);
  }
  double volatility() const {
    return GetField<double>(VT_VOLATILITY, 0.0);
  }
  bool mutate_volatility(double _volatility = 0.0) {
    return SetField<double>(VT_VOLATILITY, _volatility, 0.0);
  }
  const schwabMarketData::OptionContract *callExpDateMap() const {
    return GetPointer<const schwabMarketData::OptionContract *>(VT_CALLEXPDATEMAP);
  }
  schwabMarketData::OptionContract *mutable_callExpDateMap() {
    return GetPointer<schwabMarketData::OptionContract *>(VT_CALLEXPDATEMAP);
  }
  const schwabMarketData::OptionContract *putExpDateMap() const {
    return GetPointer<const schwabMarketData::OptionContract *>(VT_PUTEXPDATEMAP);
  }
  schwabMarketData::OptionContract *mutable_putExpDateMap() {
    return GetPointer<schwabMarketData::OptionContract *>(VT_PUTEXPDATEMAP);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SYMBOL) &&
           verifier.VerifyString(symbol()) &&
           VerifyOffset(verifier, VT_STATUS) &&
           verifier.VerifyString(status()) &&
           VerifyOffset(verifier, VT_UNDERLYING) &&
           verifier.VerifyTable(underlying()) &&
           VerifyField<int8_t>(verifier, VT_STRATEGY, 1) &&
           VerifyField<double>(verifier, VT_INTERVAL, 8) &&
           VerifyField<uint8_t>(verifier, VT_ISDELAYED, 1) &&
           VerifyField<uint8_t>(verifier, VT_ISINDEX, 1) &&
           VerifyField<double>(verifier, VT_DAYSTOEXPIRATION, 8) &&
           VerifyField<double>(verifier, VT_INTERESTRATE, 8) &&
           VerifyField<double>(verifier, VT_UNDERLYINGPRICE, 8) &&
           VerifyField<double>(verifier, VT_VOLATILITY, 8) &&
           VerifyOffset(verifier, VT_CALLEXPDATEMAP) &&
           verifier.VerifyTable(callExpDateMap()) &&
           VerifyOffset(verifier, VT_PUTEXPDATEMAP) &&
           verifier.VerifyTable(putExpDateMap()) &&
           verifier.EndTable();
  }
  OptionChainT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OptionChainT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<OptionChain> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const OptionChainT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OptionChainBuilder {
  typedef OptionChain Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_symbol(::flatbuffers::Offset<::flatbuffers::String> symbol) {
    fbb_.AddOffset(OptionChain::VT_SYMBOL, symbol);
  }
  void add_status(::flatbuffers::Offset<::flatbuffers::String> status) {
    fbb_.AddOffset(OptionChain::VT_STATUS, status);
  }
  void add_underlying(::flatbuffers::Offset<schwabMarketData::Underlying> underlying) {
    fbb_.AddOffset(OptionChain::VT_UNDERLYING, underlying);
  }
  void add_strategy(schwabMarketData::OptionStrategy strategy) {
    fbb_.AddElement<int8_t>(OptionChain::VT_STRATEGY, static_cast<int8_t>(strategy), 0);
  }
  void add_interval(double interval) {
    fbb_.AddElement<double>(OptionChain::VT_INTERVAL, interval, 0.0);
  }
  void add_isDelayed(bool isDelayed) {
    fbb_.AddElement<uint8_t>(OptionChain::VT_ISDELAYED, static_cast<uint8_t>(isDelayed), 0);
  }
  void add_isIndex(bool isIndex) {
    fbb_.AddElement<uint8_t>(OptionChain::VT_ISINDEX, static_cast<uint8_t>(isIndex), 0);
  }
  void add_daysToExpiration(double daysToExpiration) {
    fbb_.AddElement<double>(OptionChain::VT_DAYSTOEXPIRATION, daysToExpiration, 0.0);
  }
  void add_interestRate(double interestRate) {
    fbb_.AddElement<double>(OptionChain::VT_INTERESTRATE, interestRate, 0.0);
  }
  void add_underlyingPrice(double underlyingPrice) {
    fbb_.AddElement<double>(OptionChain::VT_UNDERLYINGPRICE, underlyingPrice, 0.0);
  }
  void add_volatility(double volatility) {
    fbb_.AddElement<double>(OptionChain::VT_VOLATILITY, volatility, 0.0);
  }
  void add_callExpDateMap(::flatbuffers::Offset<schwabMarketData::OptionContract> callExpDateMap) {
    fbb_.AddOffset(OptionChain::VT_CALLEXPDATEMAP, callExpDateMap);
  }
  void add_putExpDateMap(::flatbuffers::Offset<schwabMarketData::OptionContract> putExpDateMap) {
    fbb_.AddOffset(OptionChain::VT_PUTEXPDATEMAP, putExpDateMap);
  }
  explicit OptionChainBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OptionChain> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OptionChain>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OptionChain> CreateOptionChain(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> symbol = 0,
    ::flatbuffers::Offset<::flatbuffers::String> status = 0,
    ::flatbuffers::Offset<schwabMarketData::Underlying> underlying = 0,
    schwabMarketData::OptionStrategy strategy = schwabMarketData::OptionStrategy::SINGLE,
    double interval = 0.0,
    bool isDelayed = false,
    bool isIndex = false,
    double daysToExpiration = 0.0,
    double interestRate = 0.0,
    double underlyingPrice = 0.0,
    double volatility = 0.0,
    ::flatbuffers::Offset<schwabMarketData::OptionContract> callExpDateMap = 0,
    ::flatbuffers::Offset<schwabMarketData::OptionContract> putExpDateMap = 0) {
  OptionChainBuilder builder_(_fbb);
  builder_.add_volatility(volatility);
  builder_.add_underlyingPrice(underlyingPrice);
  builder_.add_interestRate(interestRate);
  builder_.add_daysToExpiration(daysToExpiration);
  builder_.add_interval(interval);
  builder_.add_putExpDateMap(putExpDateMap);
  builder_.add_callExpDateMap(callExpDateMap);
  builder_.add_underlying(underlying);
  builder_.add_status(status);
  builder_.add_symbol(symbol);
  builder_.add_isIndex(isIndex);
  builder_.add_isDelayed(isDelayed);
  builder_.add_strategy(strategy);
  return builder_.Finish();
}

struct OptionChain::Traits {
  using type = OptionChain;
  static auto constexpr Create = CreateOptionChain;
};

inline ::flatbuffers::Offset<OptionChain> CreateOptionChainDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *symbol = nullptr,
    const char *status = nullptr,
    ::flatbuffers::Offset<schwabMarketData::Underlying> underlying = 0,
    schwabMarketData::OptionStrategy strategy = schwabMarketData::OptionStrategy::SINGLE,
    double interval = 0.0,
    bool isDelayed = false,
    bool isIndex = false,
    double daysToExpiration = 0.0,
    double interestRate = 0.0,
    double underlyingPrice = 0.0,
    double volatility = 0.0,
    ::flatbuffers::Offset<schwabMarketData::OptionContract> callExpDateMap = 0,
    ::flatbuffers::Offset<schwabMarketData::OptionContract> putExpDateMap = 0) {
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  auto status__ = status ? _fbb.CreateString(status) : 0;
  return schwabMarketData::CreateOptionChain(
      _fbb,
      symbol__,
      status__,
      underlying,
      strategy,
      interval,
      isDelayed,
      isIndex,
      daysToExpiration,
      interestRate,
      underlyingPrice,
      volatility,
      callExpDateMap,
      putExpDateMap);
}

::flatbuffers::Offset<OptionChain> CreateOptionChain(::flatbuffers::FlatBufferBuilder &_fbb, const OptionChainT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);


inline bool operator==(const UnderlyingT &lhs, const UnderlyingT &rhs) {
  return
      (lhs.ask == rhs.ask) &&
      (lhs.askSize == rhs.askSize) &&
      (lhs.bid == rhs.bid) &&
      (lhs.bidSize == rhs.bidSize) &&
      (lhs.change == rhs.change) &&
      (lhs.close == rhs.close) &&
      (lhs.delayed == rhs.delayed) &&
      (lhs.description == rhs.description) &&
      (lhs.exchangeName == rhs.exchangeName) &&
      (lhs.fiftyTwoWeekHigh == rhs.fiftyTwoWeekHigh) &&
      (lhs.fiftyTwoWeekLow == rhs.fiftyTwoWeekLow) &&
      (lhs.highPrice == rhs.highPrice) &&
      (lhs.last == rhs.last) &&
      (lhs.lowPrice == rhs.lowPrice) &&
      (lhs.mark == rhs.mark) &&
      (lhs.markChange == rhs.markChange) &&
      (lhs.markPercentChange == rhs.markPercentChange) &&
      (lhs.openPrice == rhs.openPrice) &&
      (lhs.percentChange == rhs.percentChange) &&
      (lhs.quoteTime == rhs.quoteTime) &&
      (lhs.symbol == rhs.symbol) &&
      (lhs.totalVolume == rhs.totalVolume) &&
      (lhs.tradeTime == rhs.tradeTime);
}

inline bool operator!=(const UnderlyingT &lhs, const UnderlyingT &rhs) {
    return !(lhs == rhs);
}


inline UnderlyingT *Underlying::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<UnderlyingT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Underlying::UnPackTo(UnderlyingT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = ask(); _o->ask = _e; }
  { auto _e = askSize(); _o->askSize = _e; }
  { auto _e = bid(); _o->bid = _e; }
  { auto _e = bidSize(); _o->bidSize = _e; }
  { auto _e = change(); _o->change = _e; }
  { auto _e = close(); _o->close = _e; }
  { auto _e = delayed(); _o->delayed = _e; }
  { auto _e = description(); if (_e) _o->description = _e->str(); }
  { auto _e = exchangeName(); _o->exchangeName = _e; }
  { auto _e = fiftyTwoWeekHigh(); _o->fiftyTwoWeekHigh = _e; }
  { auto _e = fiftyTwoWeekLow(); _o->fiftyTwoWeekLow = _e; }
  { auto _e = highPrice(); _o->highPrice = _e; }
  { auto _e = last(); _o->last = _e; }
  { auto _e = lowPrice(); _o->lowPrice = _e; }
  { auto _e = mark(); _o->mark = _e; }
  { auto _e = markChange(); _o->markChange = _e; }
  { auto _e = markPercentChange(); _o->markPercentChange = _e; }
  { auto _e = openPrice(); _o->openPrice = _e; }
  { auto _e = percentChange(); _o->percentChange = _e; }
  { auto _e = quoteTime(); _o->quoteTime = _e; }
  { auto _e = symbol(); if (_e) _o->symbol = _e->str(); }
  { auto _e = totalVolume(); _o->totalVolume = _e; }
  { auto _e = tradeTime(); _o->tradeTime = _e; }
}

inline ::flatbuffers::Offset<Underlying> Underlying::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UnderlyingT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnderlying(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Underlying> CreateUnderlying(::flatbuffers::FlatBufferBuilder &_fbb, const UnderlyingT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const UnderlyingT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _ask = _o->ask;
  auto _askSize = _o->askSize;
  auto _bid = _o->bid;
  auto _bidSize = _o->bidSize;
  auto _change = _o->change;
  auto _close = _o->close;
  auto _delayed = _o->delayed;
  auto _description = _o->description.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->description);
  auto _exchangeName = _o->exchangeName;
  auto _fiftyTwoWeekHigh = _o->fiftyTwoWeekHigh;
  auto _fiftyTwoWeekLow = _o->fiftyTwoWeekLow;
  auto _highPrice = _o->highPrice;
  auto _last = _o->last;
  auto _lowPrice = _o->lowPrice;
  auto _mark = _o->mark;
  auto _markChange = _o->markChange;
  auto _markPercentChange = _o->markPercentChange;
  auto _openPrice = _o->openPrice;
  auto _percentChange = _o->percentChange;
  auto _quoteTime = _o->quoteTime;
  auto _symbol = _o->symbol.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->symbol);
  auto _totalVolume = _o->totalVolume;
  auto _tradeTime = _o->tradeTime;
  return schwabMarketData::CreateUnderlying(
      _fbb,
      _ask,
      _askSize,
      _bid,
      _bidSize,
      _change,
      _close,
      _delayed,
      _description,
      _exchangeName,
      _fiftyTwoWeekHigh,
      _fiftyTwoWeekLow,
      _highPrice,
      _last,
      _lowPrice,
      _mark,
      _markChange,
      _markPercentChange,
      _openPrice,
      _percentChange,
      _quoteTime,
      _symbol,
      _totalVolume,
      _tradeTime);
}


inline bool operator==(const OptionDeliverablesT &lhs, const OptionDeliverablesT &rhs) {
  return
      (lhs.symbol == rhs.symbol) &&
      (lhs.assetType == rhs.assetType) &&
      (lhs.deliverableUnits == rhs.deliverableUnits) &&
      (lhs.currencyType == rhs.currencyType);
}

inline bool operator!=(const OptionDeliverablesT &lhs, const OptionDeliverablesT &rhs) {
    return !(lhs == rhs);
}


inline OptionDeliverablesT *OptionDeliverables::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<OptionDeliverablesT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void OptionDeliverables::UnPackTo(OptionDeliverablesT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = symbol(); if (_e) _o->symbol = _e->str(); }
  { auto _e = assetType(); if (_e) _o->assetType = _e->str(); }
  { auto _e = deliverableUnits(); if (_e) _o->deliverableUnits = _e->str(); }
  { auto _e = currencyType(); if (_e) _o->currencyType = _e->str(); }
}

inline ::flatbuffers::Offset<OptionDeliverables> OptionDeliverables::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const OptionDeliverablesT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOptionDeliverables(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<OptionDeliverables> CreateOptionDeliverables(::flatbuffers::FlatBufferBuilder &_fbb, const OptionDeliverablesT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const OptionDeliverablesT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _symbol = _o->symbol.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->symbol);
  auto _assetType = _o->assetType.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->assetType);
  auto _deliverableUnits = _o->deliverableUnits.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->deliverableUnits);
  auto _currencyType = _o->currencyType.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->currencyType);
  return schwabMarketData::CreateOptionDeliverables(
      _fbb,
      _symbol,
      _assetType,
      _deliverableUnits,
      _currencyType);
}


inline bool operator==(const OptionContractT &lhs, const OptionContractT &rhs) {
  return
      (lhs.putCall == rhs.putCall) &&
      (lhs.symbol == rhs.symbol) &&
      (lhs.description == rhs.description) &&
      (lhs.exchangeName == rhs.exchangeName) &&
      (lhs.bidPrice == rhs.bidPrice) &&
      (lhs.askPrice == rhs.askPrice) &&
      (lhs.lastPrice == rhs.lastPrice) &&
      (lhs.markPrice == rhs.markPrice) &&
      (lhs.bidSize == rhs.bidSize) &&
      (lhs.askSize == rhs.askSize) &&
      (lhs.lastSize == rhs.lastSize) &&
      (lhs.highPrice == rhs.highPrice) &&
      (lhs.lowPrice == rhs.lowPrice) &&
      (lhs.openPrice == rhs.openPrice) &&
      (lhs.closePrice == rhs.closePrice) &&
      (lhs.totalVolume == rhs.totalVolume) &&
      (lhs.tradeDate == rhs.tradeDate) &&
      (lhs.quoteTimeInLong == rhs.quoteTimeInLong) &&
      (lhs.tradeTimeInLong == rhs.tradeTimeInLong) &&
      (lhs.netChange == rhs.netChange) &&
      (lhs.volatility == rhs.volatility) &&
      (lhs.delta == rhs.delta) &&
      (lhs.gamma == rhs.gamma) &&
      (lhs.theta == rhs.theta) &&
      (lhs.vega == rhs.vega) &&
      (lhs.rho == rhs.rho) &&
      (lhs.timeValue == rhs.timeValue) &&
      (lhs.openInterest == rhs.openInterest) &&
      (lhs.isInTheMoney == rhs.isInTheMoney) &&
      (lhs.theoreticalOptionValue == rhs.theoreticalOptionValue) &&
      (lhs.theoreticalVolatility == rhs.theoreticalVolatility) &&
      (lhs.isMini == rhs.isMini) &&
      (lhs.isNonStandard == rhs.isNonStandard) &&
      (lhs.optionDeliverablesList.size() == rhs.optionDeliverablesList.size() && std::equal(lhs.optionDeliverablesList.cbegin(), lhs.optionDeliverablesList.cend(), rhs.optionDeliverablesList.cbegin(), [](std::unique_ptr<schwabMarketData::OptionDeliverablesT> const &a, std::unique_ptr<schwabMarketData::OptionDeliverablesT> const &b) { return (a == b) || (a && b && *a == *b); })) &&
      (lhs.strikePrice == rhs.strikePrice) &&
      (lhs.expirationDate == rhs.expirationDate) &&
      (lhs.daysToExpiration == rhs.daysToExpiration) &&
      (lhs.expirationType == rhs.expirationType) &&
      (lhs.lastTradingDay == rhs.lastTradingDay) &&
      (lhs.multiplier == rhs.multiplier) &&
      (lhs.settlementType == rhs.settlementType) &&
      (lhs.deliverableNote == rhs.deliverableNote) &&
      (lhs.isIndexOption == rhs.isIndexOption) &&
      (lhs.percentChange == rhs.percentChange) &&
      (lhs.markChange == rhs.markChange) &&
      (lhs.markPercentChange == rhs.markPercentChange) &&
      (lhs.isPennyPilot == rhs.isPennyPilot) &&
      (lhs.intrinsicValue == rhs.intrinsicValue) &&
      (lhs.optionRoot == rhs.optionRoot);
}

inline bool operator!=(const OptionContractT &lhs, const OptionContractT &rhs) {
    return !(lhs == rhs);
}


inline OptionContractT::OptionContractT(const OptionContractT &o)
      : putCall(o.putCall),
        symbol(o.symbol),
        description(o.description),
        exchangeName(o.exchangeName),
        bidPrice(o.bidPrice),
        askPrice(o.askPrice),
        lastPrice(o.lastPrice),
        markPrice(o.markPrice),
        bidSize(o.bidSize),
        askSize(o.askSize),
        lastSize(o.lastSize),
        highPrice(o.highPrice),
        lowPrice(o.lowPrice),
        openPrice(o.openPrice),
        closePrice(o.closePrice),
        totalVolume(o.totalVolume),
        tradeDate(o.tradeDate),
        quoteTimeInLong(o.quoteTimeInLong),
        tradeTimeInLong(o.tradeTimeInLong),
        netChange(o.netChange),
        volatility(o.volatility),
        delta(o.delta),
        gamma(o.gamma),
        theta(o.theta),
        vega(o.vega),
        rho(o.rho),
        timeValue(o.timeValue),
        openInterest(o.openInterest),
        isInTheMoney(o.isInTheMoney),
        theoreticalOptionValue(o.theoreticalOptionValue),
        theoreticalVolatility(o.theoreticalVolatility),
        isMini(o.isMini),
        isNonStandard(o.isNonStandard),
        strikePrice(o.strikePrice),
        expirationDate(o.expirationDate),
        daysToExpiration(o.daysToExpiration),
        expirationType(o.expirationType),
        lastTradingDay(o.lastTradingDay),
        multiplier(o.multiplier),
        settlementType(o.settlementType),
        deliverableNote(o.deliverableNote),
        isIndexOption(o.isIndexOption),
        percentChange(o.percentChange),
        markChange(o.markChange),
        markPercentChange(o.markPercentChange),
        isPennyPilot(o.isPennyPilot),
        intrinsicValue(o.intrinsicValue),
        optionRoot(o.optionRoot) {
  optionDeliverablesList.reserve(o.optionDeliverablesList.size());
  for (const auto &optionDeliverablesList_ : o.optionDeliverablesList) { optionDeliverablesList.emplace_back((optionDeliverablesList_) ? new schwabMarketData::OptionDeliverablesT(*optionDeliverablesList_) : nullptr); }
}

inline OptionContractT &OptionContractT::operator=(OptionContractT o) FLATBUFFERS_NOEXCEPT {
  std::swap(putCall, o.putCall);
  std::swap(symbol, o.symbol);
  std::swap(description, o.description);
  std::swap(exchangeName, o.exchangeName);
  std::swap(bidPrice, o.bidPrice);
  std::swap(askPrice, o.askPrice);
  std::swap(lastPrice, o.lastPrice);
  std::swap(markPrice, o.markPrice);
  std::swap(bidSize, o.bidSize);
  std::swap(askSize, o.askSize);
  std::swap(lastSize, o.lastSize);
  std::swap(highPrice, o.highPrice);
  std::swap(lowPrice, o.lowPrice);
  std::swap(openPrice, o.openPrice);
  std::swap(closePrice, o.closePrice);
  std::swap(totalVolume, o.totalVolume);
  std::swap(tradeDate, o.tradeDate);
  std::swap(quoteTimeInLong, o.quoteTimeInLong);
  std::swap(tradeTimeInLong, o.tradeTimeInLong);
  std::swap(netChange, o.netChange);
  std::swap(volatility, o.volatility);
  std::swap(delta, o.delta);
  std::swap(gamma, o.gamma);
  std::swap(theta, o.theta);
  std::swap(vega, o.vega);
  std::swap(rho, o.rho);
  std::swap(timeValue, o.timeValue);
  std::swap(openInterest, o.openInterest);
  std::swap(isInTheMoney, o.isInTheMoney);
  std::swap(theoreticalOptionValue, o.theoreticalOptionValue);
  std::swap(theoreticalVolatility, o.theoreticalVolatility);
  std::swap(isMini, o.isMini);
  std::swap(isNonStandard, o.isNonStandard);
  std::swap(optionDeliverablesList, o.optionDeliverablesList);
  std::swap(strikePrice, o.strikePrice);
  std::swap(expirationDate, o.expirationDate);
  std::swap(daysToExpiration, o.daysToExpiration);
  std::swap(expirationType, o.expirationType);
  std::swap(lastTradingDay, o.lastTradingDay);
  std::swap(multiplier, o.multiplier);
  std::swap(settlementType, o.settlementType);
  std::swap(deliverableNote, o.deliverableNote);
  std::swap(isIndexOption, o.isIndexOption);
  std::swap(percentChange, o.percentChange);
  std::swap(markChange, o.markChange);
  std::swap(markPercentChange, o.markPercentChange);
  std::swap(isPennyPilot, o.isPennyPilot);
  std::swap(intrinsicValue, o.intrinsicValue);
  std::swap(optionRoot, o.optionRoot);
  return *this;
}

inline OptionContractT *OptionContract::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<OptionContractT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void OptionContract::UnPackTo(OptionContractT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = putCall(); _o->putCall = _e; }
  { auto _e = symbol(); if (_e) _o->symbol = _e->str(); }
  { auto _e = description(); if (_e) _o->description = _e->str(); }
  { auto _e = exchangeName(); if (_e) _o->exchangeName = _e->str(); }
  { auto _e = bidPrice(); _o->bidPrice = _e; }
  { auto _e = askPrice(); _o->askPrice = _e; }
  { auto _e = lastPrice(); _o->lastPrice = _e; }
  { auto _e = markPrice(); _o->markPrice = _e; }
  { auto _e = bidSize(); _o->bidSize = _e; }
  { auto _e = askSize(); _o->askSize = _e; }
  { auto _e = lastSize(); _o->lastSize = _e; }
  { auto _e = highPrice(); _o->highPrice = _e; }
  { auto _e = lowPrice(); _o->lowPrice = _e; }
  { auto _e = openPrice(); _o->openPrice = _e; }
  { auto _e = closePrice(); _o->closePrice = _e; }
  { auto _e = totalVolume(); _o->totalVolume = _e; }
  { auto _e = tradeDate(); _o->tradeDate = _e; }
  { auto _e = quoteTimeInLong(); _o->quoteTimeInLong = _e; }
  { auto _e = tradeTimeInLong(); _o->tradeTimeInLong = _e; }
  { auto _e = netChange(); _o->netChange = _e; }
  { auto _e = volatility(); _o->volatility = _e; }
  { auto _e = delta(); _o->delta = _e; }
  { auto _e = gamma(); _o->gamma = _e; }
  { auto _e = theta(); _o->theta = _e; }
  { auto _e = vega(); _o->vega = _e; }
  { auto _e = rho(); _o->rho = _e; }
  { auto _e = timeValue(); _o->timeValue = _e; }
  { auto _e = openInterest(); _o->openInterest = _e; }
  { auto _e = isInTheMoney(); _o->isInTheMoney = _e; }
  { auto _e = theoreticalOptionValue(); _o->theoreticalOptionValue = _e; }
  { auto _e = theoreticalVolatility(); _o->theoreticalVolatility = _e; }
  { auto _e = isMini(); _o->isMini = _e; }
  { auto _e = isNonStandard(); _o->isNonStandard = _e; }
  { auto _e = optionDeliverablesList(); if (_e) { _o->optionDeliverablesList.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->optionDeliverablesList[_i]) { _e->Get(_i)->UnPackTo(_o->optionDeliverablesList[_i].get(), _resolver); } else { _o->optionDeliverablesList[_i] = std::unique_ptr<schwabMarketData::OptionDeliverablesT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->optionDeliverablesList.resize(0); } }
  { auto _e = strikePrice(); _o->strikePrice = _e; }
  { auto _e = expirationDate(); if (_e) _o->expirationDate = _e->str(); }
  { auto _e = daysToExpiration(); _o->daysToExpiration = _e; }
  { auto _e = expirationType(); _o->expirationType = _e; }
  { auto _e = lastTradingDay(); _o->lastTradingDay = _e; }
  { auto _e = multiplier(); _o->multiplier = _e; }
  { auto _e = settlementType(); _o->settlementType = _e; }
  { auto _e = deliverableNote(); if (_e) _o->deliverableNote = _e->str(); }
  { auto _e = isIndexOption(); _o->isIndexOption = _e; }
  { auto _e = percentChange(); _o->percentChange = _e; }
  { auto _e = markChange(); _o->markChange = _e; }
  { auto _e = markPercentChange(); _o->markPercentChange = _e; }
  { auto _e = isPennyPilot(); _o->isPennyPilot = _e; }
  { auto _e = intrinsicValue(); _o->intrinsicValue = _e; }
  { auto _e = optionRoot(); if (_e) _o->optionRoot = _e->str(); }
}

inline ::flatbuffers::Offset<OptionContract> OptionContract::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const OptionContractT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOptionContract(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<OptionContract> CreateOptionContract(::flatbuffers::FlatBufferBuilder &_fbb, const OptionContractT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const OptionContractT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _putCall = _o->putCall;
  auto _symbol = _o->symbol.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->symbol);
  auto _description = _o->description.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->description);
  auto _exchangeName = _o->exchangeName.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->exchangeName);
  auto _bidPrice = _o->bidPrice;
  auto _askPrice = _o->askPrice;
  auto _lastPrice = _o->lastPrice;
  auto _markPrice = _o->markPrice;
  auto _bidSize = _o->bidSize;
  auto _askSize = _o->askSize;
  auto _lastSize = _o->lastSize;
  auto _highPrice = _o->highPrice;
  auto _lowPrice = _o->lowPrice;
  auto _openPrice = _o->openPrice;
  auto _closePrice = _o->closePrice;
  auto _totalVolume = _o->totalVolume;
  auto _tradeDate = _o->tradeDate;
  auto _quoteTimeInLong = _o->quoteTimeInLong;
  auto _tradeTimeInLong = _o->tradeTimeInLong;
  auto _netChange = _o->netChange;
  auto _volatility = _o->volatility;
  auto _delta = _o->delta;
  auto _gamma = _o->gamma;
  auto _theta = _o->theta;
  auto _vega = _o->vega;
  auto _rho = _o->rho;
  auto _timeValue = _o->timeValue;
  auto _openInterest = _o->openInterest;
  auto _isInTheMoney = _o->isInTheMoney;
  auto _theoreticalOptionValue = _o->theoreticalOptionValue;
  auto _theoreticalVolatility = _o->theoreticalVolatility;
  auto _isMini = _o->isMini;
  auto _isNonStandard = _o->isNonStandard;
  auto _optionDeliverablesList = _fbb.CreateVector<::flatbuffers::Offset<schwabMarketData::OptionDeliverables>> (_o->optionDeliverablesList.size(), [](size_t i, _VectorArgs *__va) { return CreateOptionDeliverables(*__va->__fbb, __va->__o->optionDeliverablesList[i].get(), __va->__rehasher); }, &_va );
  auto _strikePrice = _o->strikePrice;
  auto _expirationDate = _o->expirationDate.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->expirationDate);
  auto _daysToExpiration = _o->daysToExpiration;
  auto _expirationType = _o->expirationType;
  auto _lastTradingDay = _o->lastTradingDay;
  auto _multiplier = _o->multiplier;
  auto _settlementType = _o->settlementType;
  auto _deliverableNote = _o->deliverableNote.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->deliverableNote);
  auto _isIndexOption = _o->isIndexOption;
  auto _percentChange = _o->percentChange;
  auto _markChange = _o->markChange;
  auto _markPercentChange = _o->markPercentChange;
  auto _isPennyPilot = _o->isPennyPilot;
  auto _intrinsicValue = _o->intrinsicValue;
  auto _optionRoot = _o->optionRoot.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->optionRoot);
  return schwabMarketData::CreateOptionContract(
      _fbb,
      _putCall,
      _symbol,
      _description,
      _exchangeName,
      _bidPrice,
      _askPrice,
      _lastPrice,
      _markPrice,
      _bidSize,
      _askSize,
      _lastSize,
      _highPrice,
      _lowPrice,
      _openPrice,
      _closePrice,
      _totalVolume,
      _tradeDate,
      _quoteTimeInLong,
      _tradeTimeInLong,
      _netChange,
      _volatility,
      _delta,
      _gamma,
      _theta,
      _vega,
      _rho,
      _timeValue,
      _openInterest,
      _isInTheMoney,
      _theoreticalOptionValue,
      _theoreticalVolatility,
      _isMini,
      _isNonStandard,
      _optionDeliverablesList,
      _strikePrice,
      _expirationDate,
      _daysToExpiration,
      _expirationType,
      _lastTradingDay,
      _multiplier,
      _settlementType,
      _deliverableNote,
      _isIndexOption,
      _percentChange,
      _markChange,
      _markPercentChange,
      _isPennyPilot,
      _intrinsicValue,
      _optionRoot);
}


inline bool operator==(const OptionContractMapT &, const OptionContractMapT &) {
  return true;
}

inline bool operator!=(const OptionContractMapT &lhs, const OptionContractMapT &rhs) {
    return !(lhs == rhs);
}


inline OptionContractMapT *OptionContractMap::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<OptionContractMapT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void OptionContractMap::UnPackTo(OptionContractMapT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<OptionContractMap> OptionContractMap::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const OptionContractMapT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOptionContractMap(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<OptionContractMap> CreateOptionContractMap(::flatbuffers::FlatBufferBuilder &_fbb, const OptionContractMapT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const OptionContractMapT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return schwabMarketData::CreateOptionContractMap(
      _fbb);
}


inline bool operator==(const OptionChainT &lhs, const OptionChainT &rhs) {
  return
      (lhs.symbol == rhs.symbol) &&
      (lhs.status == rhs.status) &&
      ((lhs.underlying == rhs.underlying) || (lhs.underlying && rhs.underlying && *lhs.underlying == *rhs.underlying)) &&
      (lhs.strategy == rhs.strategy) &&
      (lhs.interval == rhs.interval) &&
      (lhs.isDelayed == rhs.isDelayed) &&
      (lhs.isIndex == rhs.isIndex) &&
      (lhs.daysToExpiration == rhs.daysToExpiration) &&
      (lhs.interestRate == rhs.interestRate) &&
      (lhs.underlyingPrice == rhs.underlyingPrice) &&
      (lhs.volatility == rhs.volatility) &&
      ((lhs.callExpDateMap == rhs.callExpDateMap) || (lhs.callExpDateMap && rhs.callExpDateMap && *lhs.callExpDateMap == *rhs.callExpDateMap)) &&
      ((lhs.putExpDateMap == rhs.putExpDateMap) || (lhs.putExpDateMap && rhs.putExpDateMap && *lhs.putExpDateMap == *rhs.putExpDateMap));
}

inline bool operator!=(const OptionChainT &lhs, const OptionChainT &rhs) {
    return !(lhs == rhs);
}


inline OptionChainT::OptionChainT(const OptionChainT &o)
      : symbol(o.symbol),
        status(o.status),
        underlying((o.underlying) ? new schwabMarketData::UnderlyingT(*o.underlying) : nullptr),
        strategy(o.strategy),
        interval(o.interval),
        isDelayed(o.isDelayed),
        isIndex(o.isIndex),
        daysToExpiration(o.daysToExpiration),
        interestRate(o.interestRate),
        underlyingPrice(o.underlyingPrice),
        volatility(o.volatility),
        callExpDateMap((o.callExpDateMap) ? new schwabMarketData::OptionContractT(*o.callExpDateMap) : nullptr),
        putExpDateMap((o.putExpDateMap) ? new schwabMarketData::OptionContractT(*o.putExpDateMap) : nullptr) {
}

inline OptionChainT &OptionChainT::operator=(OptionChainT o) FLATBUFFERS_NOEXCEPT {
  std::swap(symbol, o.symbol);
  std::swap(status, o.status);
  std::swap(underlying, o.underlying);
  std::swap(strategy, o.strategy);
  std::swap(interval, o.interval);
  std::swap(isDelayed, o.isDelayed);
  std::swap(isIndex, o.isIndex);
  std::swap(daysToExpiration, o.daysToExpiration);
  std::swap(interestRate, o.interestRate);
  std::swap(underlyingPrice, o.underlyingPrice);
  std::swap(volatility, o.volatility);
  std::swap(callExpDateMap, o.callExpDateMap);
  std::swap(putExpDateMap, o.putExpDateMap);
  return *this;
}

inline OptionChainT *OptionChain::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<OptionChainT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void OptionChain::UnPackTo(OptionChainT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = symbol(); if (_e) _o->symbol = _e->str(); }
  { auto _e = status(); if (_e) _o->status = _e->str(); }
  { auto _e = underlying(); if (_e) { if(_o->underlying) { _e->UnPackTo(_o->underlying.get(), _resolver); } else { _o->underlying = std::unique_ptr<schwabMarketData::UnderlyingT>(_e->UnPack(_resolver)); } } else if (_o->underlying) { _o->underlying.reset(); } }
  { auto _e = strategy(); _o->strategy = _e; }
  { auto _e = interval(); _o->interval = _e; }
  { auto _e = isDelayed(); _o->isDelayed = _e; }
  { auto _e = isIndex(); _o->isIndex = _e; }
  { auto _e = daysToExpiration(); _o->daysToExpiration = _e; }
  { auto _e = interestRate(); _o->interestRate = _e; }
  { auto _e = underlyingPrice(); _o->underlyingPrice = _e; }
  { auto _e = volatility(); _o->volatility = _e; }
  { auto _e = callExpDateMap(); if (_e) { if(_o->callExpDateMap) { _e->UnPackTo(_o->callExpDateMap.get(), _resolver); } else { _o->callExpDateMap = std::unique_ptr<schwabMarketData::OptionContractT>(_e->UnPack(_resolver)); } } else if (_o->callExpDateMap) { _o->callExpDateMap.reset(); } }
  { auto _e = putExpDateMap(); if (_e) { if(_o->putExpDateMap) { _e->UnPackTo(_o->putExpDateMap.get(), _resolver); } else { _o->putExpDateMap = std::unique_ptr<schwabMarketData::OptionContractT>(_e->UnPack(_resolver)); } } else if (_o->putExpDateMap) { _o->putExpDateMap.reset(); } }
}

inline ::flatbuffers::Offset<OptionChain> OptionChain::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const OptionChainT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOptionChain(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<OptionChain> CreateOptionChain(::flatbuffers::FlatBufferBuilder &_fbb, const OptionChainT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const OptionChainT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _symbol = _o->symbol.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->symbol);
  auto _status = _o->status.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->status);
  auto _underlying = _o->underlying ? CreateUnderlying(_fbb, _o->underlying.get(), _rehasher) : 0;
  auto _strategy = _o->strategy;
  auto _interval = _o->interval;
  auto _isDelayed = _o->isDelayed;
  auto _isIndex = _o->isIndex;
  auto _daysToExpiration = _o->daysToExpiration;
  auto _interestRate = _o->interestRate;
  auto _underlyingPrice = _o->underlyingPrice;
  auto _volatility = _o->volatility;
  auto _callExpDateMap = _o->callExpDateMap ? CreateOptionContract(_fbb, _o->callExpDateMap.get(), _rehasher) : 0;
  auto _putExpDateMap = _o->putExpDateMap ? CreateOptionContract(_fbb, _o->putExpDateMap.get(), _rehasher) : 0;
  return schwabMarketData::CreateOptionChain(
      _fbb,
      _symbol,
      _status,
      _underlying,
      _strategy,
      _interval,
      _isDelayed,
      _isIndex,
      _daysToExpiration,
      _interestRate,
      _underlyingPrice,
      _volatility,
      _callExpDateMap,
      _putExpDateMap);
}

inline const schwabMarketData::OptionChain *GetOptionChain(const void *buf) {
  return ::flatbuffers::GetRoot<schwabMarketData::OptionChain>(buf);
}

inline const schwabMarketData::OptionChain *GetSizePrefixedOptionChain(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<schwabMarketData::OptionChain>(buf);
}

inline OptionChain *GetMutableOptionChain(void *buf) {
  return ::flatbuffers::GetMutableRoot<OptionChain>(buf);
}

inline schwabMarketData::OptionChain *GetMutableSizePrefixedOptionChain(void *buf) {
  return ::flatbuffers::GetMutableSizePrefixedRoot<schwabMarketData::OptionChain>(buf);
}

inline bool VerifyOptionChainBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<schwabMarketData::OptionChain>(nullptr);
}

inline bool VerifySizePrefixedOptionChainBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<schwabMarketData::OptionChain>(nullptr);
}

inline void FinishOptionChainBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<schwabMarketData::OptionChain> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedOptionChainBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<schwabMarketData::OptionChain> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<schwabMarketData::OptionChainT> UnPackOptionChain(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<schwabMarketData::OptionChainT>(GetOptionChain(buf)->UnPack(res));
}

inline std::unique_ptr<schwabMarketData::OptionChainT> UnPackSizePrefixedOptionChain(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<schwabMarketData::OptionChainT>(GetSizePrefixedOptionChain(buf)->UnPack(res));
}

}  // namespace schwabMarketData

#endif  // FLATBUFFERS_GENERATED_SCHWABOPTIONCHAIN_SCHWABMARKETDATA_H_
