// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SCHWABAUTH_SCHWABAUTHENTICATION_H_
#define FLATBUFFERS_GENERATED_SCHWABAUTH_SCHWABAUTHENTICATION_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

namespace schwabAuthentication {

struct Auths;
struct AuthsBuilder;
struct AuthsT;

bool operator==(const AuthsT &lhs, const AuthsT &rhs);
bool operator!=(const AuthsT &lhs, const AuthsT &rhs);

struct AuthsT : public ::flatbuffers::NativeTable {
  typedef Auths TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "schwabAuthentication.AuthsT";
  }
  std::string appkey{};
  std::string appsecret{};
};

struct Auths FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AuthsT NativeTableType;
  typedef AuthsBuilder Builder;
  struct Traits;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "schwabAuthentication.Auths";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_APPKEY = 4,
    VT_APPSECRET = 6
  };
  const ::flatbuffers::String *appkey() const {
    return GetPointer<const ::flatbuffers::String *>(VT_APPKEY);
  }
  ::flatbuffers::String *mutable_appkey() {
    return GetPointer<::flatbuffers::String *>(VT_APPKEY);
  }
  const ::flatbuffers::String *appsecret() const {
    return GetPointer<const ::flatbuffers::String *>(VT_APPSECRET);
  }
  ::flatbuffers::String *mutable_appsecret() {
    return GetPointer<::flatbuffers::String *>(VT_APPSECRET);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_APPKEY) &&
           verifier.VerifyString(appkey()) &&
           VerifyOffset(verifier, VT_APPSECRET) &&
           verifier.VerifyString(appsecret()) &&
           verifier.EndTable();
  }
  AuthsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AuthsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Auths> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AuthsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AuthsBuilder {
  typedef Auths Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_appkey(::flatbuffers::Offset<::flatbuffers::String> appkey) {
    fbb_.AddOffset(Auths::VT_APPKEY, appkey);
  }
  void add_appsecret(::flatbuffers::Offset<::flatbuffers::String> appsecret) {
    fbb_.AddOffset(Auths::VT_APPSECRET, appsecret);
  }
  explicit AuthsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Auths> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Auths>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Auths> CreateAuths(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> appkey = 0,
    ::flatbuffers::Offset<::flatbuffers::String> appsecret = 0) {
  AuthsBuilder builder_(_fbb);
  builder_.add_appsecret(appsecret);
  builder_.add_appkey(appkey);
  return builder_.Finish();
}

struct Auths::Traits {
  using type = Auths;
  static auto constexpr Create = CreateAuths;
};

inline ::flatbuffers::Offset<Auths> CreateAuthsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *appkey = nullptr,
    const char *appsecret = nullptr) {
  auto appkey__ = appkey ? _fbb.CreateString(appkey) : 0;
  auto appsecret__ = appsecret ? _fbb.CreateString(appsecret) : 0;
  return schwabAuthentication::CreateAuths(
      _fbb,
      appkey__,
      appsecret__);
}

::flatbuffers::Offset<Auths> CreateAuths(::flatbuffers::FlatBufferBuilder &_fbb, const AuthsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);


inline bool operator==(const AuthsT &lhs, const AuthsT &rhs) {
  return
      (lhs.appkey == rhs.appkey) &&
      (lhs.appsecret == rhs.appsecret);
}

inline bool operator!=(const AuthsT &lhs, const AuthsT &rhs) {
    return !(lhs == rhs);
}


inline AuthsT *Auths::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<AuthsT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Auths::UnPackTo(AuthsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = appkey(); if (_e) _o->appkey = _e->str(); }
  { auto _e = appsecret(); if (_e) _o->appsecret = _e->str(); }
}

inline ::flatbuffers::Offset<Auths> Auths::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AuthsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAuths(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Auths> CreateAuths(::flatbuffers::FlatBufferBuilder &_fbb, const AuthsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const AuthsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _appkey = _o->appkey.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->appkey);
  auto _appsecret = _o->appsecret.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->appsecret);
  return schwabAuthentication::CreateAuths(
      _fbb,
      _appkey,
      _appsecret);
}

inline const schwabAuthentication::Auths *GetAuths(const void *buf) {
  return ::flatbuffers::GetRoot<schwabAuthentication::Auths>(buf);
}

inline const schwabAuthentication::Auths *GetSizePrefixedAuths(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<schwabAuthentication::Auths>(buf);
}

inline Auths *GetMutableAuths(void *buf) {
  return ::flatbuffers::GetMutableRoot<Auths>(buf);
}

inline schwabAuthentication::Auths *GetMutableSizePrefixedAuths(void *buf) {
  return ::flatbuffers::GetMutableSizePrefixedRoot<schwabAuthentication::Auths>(buf);
}

inline bool VerifyAuthsBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<schwabAuthentication::Auths>(nullptr);
}

inline bool VerifySizePrefixedAuthsBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<schwabAuthentication::Auths>(nullptr);
}

inline void FinishAuthsBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<schwabAuthentication::Auths> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedAuthsBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<schwabAuthentication::Auths> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<schwabAuthentication::AuthsT> UnPackAuths(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<schwabAuthentication::AuthsT>(GetAuths(buf)->UnPack(res));
}

inline std::unique_ptr<schwabAuthentication::AuthsT> UnPackSizePrefixedAuths(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<schwabAuthentication::AuthsT>(GetSizePrefixedAuths(buf)->UnPack(res));
}

}  // namespace schwabAuthentication

#endif  // FLATBUFFERS_GENERATED_SCHWABAUTH_SCHWABAUTHENTICATION_H_
